<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="An ordered sequence stream of elements of type `T`."><title>Stream in hydro_lang::stream - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../static.files/rustdoc-916cea96.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="hydro_lang" data-themes="" data-resource-suffix="" data-rustdoc-version="1.87.0-nightly (3ea711f17 2025-03-09)" data-channel="nightly" data-search-js="search-e7298875.js" data-settings-js="settings-d72f25bb.js" ><script src="../../static.files/storage-d8ac8691.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../static.files/main-a7bf3405.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-044be391.svg"></head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../hydro_lang/index.html">hydro_<wbr>lang</a><span class="version">0.12.1</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Stream</a></h2><h3><a href="#implementations">Methods</a></h3><ul class="block method"><li><a href="#method.all_ticks" title="all_ticks">all_ticks</a></li><li><a href="#method.all_ticks_atomic" title="all_ticks_atomic">all_ticks_atomic</a></li><li><a href="#method.anti_join" title="anti_join">anti_join</a></li><li><a href="#method.assume_ordering" title="assume_ordering">assume_ordering</a></li><li><a href="#method.atomic" title="atomic">atomic</a></li><li><a href="#method.atomic_source" title="atomic_source">atomic_source</a></li><li><a href="#method.broadcast_bincode" title="broadcast_bincode">broadcast_bincode</a></li><li><a href="#method.broadcast_bincode_anonymous" title="broadcast_bincode_anonymous">broadcast_bincode_anonymous</a></li><li><a href="#method.broadcast_bytes" title="broadcast_bytes">broadcast_bytes</a></li><li><a href="#method.broadcast_bytes_anonymous" title="broadcast_bytes_anonymous">broadcast_bytes_anonymous</a></li><li><a href="#method.chain" title="chain">chain</a></li><li><a href="#method.cloned" title="cloned">cloned</a></li><li><a href="#method.continue_if" title="continue_if">continue_if</a></li><li><a href="#method.continue_unless" title="continue_unless">continue_unless</a></li><li><a href="#method.count" title="count">count</a></li><li><a href="#method.cross_product" title="cross_product">cross_product</a></li><li><a href="#method.cross_singleton" title="cross_singleton">cross_singleton</a></li><li><a href="#method.defer_tick" title="defer_tick">defer_tick</a></li><li><a href="#method.delta" title="delta">delta</a></li><li><a href="#method.dest_sink" title="dest_sink">dest_sink</a></li><li><a href="#method.end_atomic" title="end_atomic">end_atomic</a></li><li><a href="#method.enumerate" title="enumerate">enumerate</a></li><li><a href="#method.filter" title="filter">filter</a></li><li><a href="#method.filter_map" title="filter_map">filter_map</a></li><li><a href="#method.filter_not_in" title="filter_not_in">filter_not_in</a></li><li><a href="#method.first" title="first">first</a></li><li><a href="#method.flat_map_ordered" title="flat_map_ordered">flat_map_ordered</a></li><li><a href="#method.flat_map_unordered" title="flat_map_unordered">flat_map_unordered</a></li><li><a href="#method.flatten_ordered" title="flatten_ordered">flatten_ordered</a></li><li><a href="#method.flatten_unordered" title="flatten_unordered">flatten_unordered</a></li><li><a href="#method.fold" title="fold">fold</a></li><li><a href="#method.fold_commutative" title="fold_commutative">fold_commutative</a></li><li><a href="#method.fold_keyed" title="fold_keyed">fold_keyed</a></li><li><a href="#method.fold_keyed_commutative" title="fold_keyed_commutative">fold_keyed_commutative</a></li><li><a href="#method.for_each" title="for_each">for_each</a></li><li><a href="#method.inspect" title="inspect">inspect</a></li><li><a href="#method.join" title="join">join</a></li><li><a href="#method.keys" title="keys">keys</a></li><li><a href="#method.last" title="last">last</a></li><li><a href="#method.map" title="map">map</a></li><li><a href="#method.max" title="max">max</a></li><li><a href="#method.max_by_key" title="max_by_key">max_by_key</a></li><li><a href="#method.min" title="min">min</a></li><li><a href="#method.persist" title="persist">persist</a></li><li><a href="#method.reduce" title="reduce">reduce</a></li><li><a href="#method.reduce_commutative" title="reduce_commutative">reduce_commutative</a></li><li><a href="#method.reduce_keyed" title="reduce_keyed">reduce_keyed</a></li><li><a href="#method.reduce_keyed_commutative" title="reduce_keyed_commutative">reduce_keyed_commutative</a></li><li><a href="#method.resolve_futures" title="resolve_futures">resolve_futures</a></li><li><a href="#method.resolve_futures_ordered" title="resolve_futures_ordered">resolve_futures_ordered</a></li><li><a href="#method.round_robin_bincode" title="round_robin_bincode">round_robin_bincode</a></li><li><a href="#method.round_robin_bincode_anonymous" title="round_robin_bincode_anonymous">round_robin_bincode_anonymous</a></li><li><a href="#method.round_robin_bytes" title="round_robin_bytes">round_robin_bytes</a></li><li><a href="#method.round_robin_bytes_anonymous" title="round_robin_bytes_anonymous">round_robin_bytes_anonymous</a></li><li><a href="#method.sample_every" title="sample_every">sample_every</a></li><li><a href="#method.send_bincode" title="send_bincode">send_bincode</a></li><li><a href="#method.send_bincode_anonymous" title="send_bincode_anonymous">send_bincode_anonymous</a></li><li><a href="#method.send_bincode_external" title="send_bincode_external">send_bincode_external</a></li><li><a href="#method.send_bytes" title="send_bytes">send_bytes</a></li><li><a href="#method.send_bytes_anonymous" title="send_bytes_anonymous">send_bytes_anonymous</a></li><li><a href="#method.send_bytes_external" title="send_bytes_external">send_bytes_external</a></li><li><a href="#method.sort" title="sort">sort</a></li><li><a href="#method.tick_batch" title="tick_batch">tick_batch</a></li><li><a href="#method.tick_batch-1" title="tick_batch">tick_batch</a></li><li><a href="#method.timeout" title="timeout">timeout</a></li><li><a href="#method.union" title="union">union</a></li><li><a href="#method.unique" title="unique">unique</a></li></ul><h3><a href="#trait-implementations">Trait Implementations</a></h3><ul class="block trait-implementation"><li><a href="#impl-Clone-for-Stream%3CT,+L,+B,+Order%3E" title="Clone">Clone</a></li><li><a href="#impl-CycleCollection%3C'a,+ForwardRefMarker%3E-for-Stream%3CT,+L,+B,+Order%3E" title="CycleCollection&#60;&#39;a, ForwardRefMarker&#62;">CycleCollection&#60;&#39;a, ForwardRefMarker&#62;</a></li><li><a href="#impl-CycleCollection%3C'a,+TickCycleMarker%3E-for-Stream%3CT,+Tick%3CL%3E,+Bounded,+Order%3E" title="CycleCollection&#60;&#39;a, TickCycleMarker&#62;">CycleCollection&#60;&#39;a, TickCycleMarker&#62;</a></li><li><a href="#impl-CycleComplete%3C'a,+ForwardRefMarker%3E-for-Stream%3CT,+L,+B,+Order%3E" title="CycleComplete&#60;&#39;a, ForwardRefMarker&#62;">CycleComplete&#60;&#39;a, ForwardRefMarker&#62;</a></li><li><a href="#impl-CycleComplete%3C'a,+TickCycleMarker%3E-for-Stream%3CT,+Tick%3CL%3E,+Bounded,+Order%3E" title="CycleComplete&#60;&#39;a, TickCycleMarker&#62;">CycleComplete&#60;&#39;a, TickCycleMarker&#62;</a></li><li><a href="#impl-DeferTick-for-Stream%3CT,+Tick%3CL%3E,+Bounded,+Order%3E" title="DeferTick">DeferTick</a></li><li><a href="#impl-From%3CStream%3CT,+L,+B%3E%3E-for-Stream%3CT,+L,+B,+NoOrder%3E" title="From&#60;Stream&#60;T, L, B&#62;&#62;">From&#60;Stream&#60;T, L, B&#62;&#62;</a></li><li><a href="#impl-From%3CStream%3CT,+L,+Bounded,+O%3E%3E-for-Stream%3CT,+L,+Unbounded,+O%3E" title="From&#60;Stream&#60;T, L, Bounded, O&#62;&#62;">From&#60;Stream&#60;T, L, Bounded, O&#62;&#62;</a></li></ul><h3><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul class="block synthetic-implementation"><li><a href="#impl-Freeze-for-Stream%3CT,+L,+B,+Order%3E" title="!Freeze">!Freeze</a></li><li><a href="#impl-RefUnwindSafe-for-Stream%3CT,+L,+B,+Order%3E" title="!RefUnwindSafe">!RefUnwindSafe</a></li><li><a href="#impl-Send-for-Stream%3CT,+L,+B,+Order%3E" title="!Send">!Send</a></li><li><a href="#impl-Sync-for-Stream%3CT,+L,+B,+Order%3E" title="!Sync">!Sync</a></li><li><a href="#impl-UnwindSafe-for-Stream%3CT,+L,+B,+Order%3E" title="!UnwindSafe">!UnwindSafe</a></li><li><a href="#impl-Unpin-for-Stream%3CT,+L,+B,+Order%3E" title="Unpin">Unpin</a></li></ul><h3><a href="#blanket-implementations">Blanket Implementations</a></h3><ul class="block blanket-implementation"><li><a href="#impl-Any-for-T" title="Any">Any</a></li><li><a href="#impl-Borrow%3CT%3E-for-T" title="Borrow&#60;T&#62;">Borrow&#60;T&#62;</a></li><li><a href="#impl-BorrowMut%3CT%3E-for-T" title="BorrowMut&#60;T&#62;">BorrowMut&#60;T&#62;</a></li><li><a href="#impl-CloneToUninit-for-T" title="CloneToUninit">CloneToUninit</a></li><li><a href="#impl-DynClone-for-T" title="DynClone">DynClone</a></li><li><a href="#impl-ErasedDestructor-for-T" title="ErasedDestructor">ErasedDestructor</a></li><li><a href="#impl-From%3CT%3E-for-T" title="From&#60;T&#62;">From&#60;T&#62;</a></li><li><a href="#impl-Instrument-for-T" title="Instrument">Instrument</a></li><li><a href="#impl-Into%3CU%3E-for-T" title="Into&#60;U&#62;">Into&#60;U&#62;</a></li><li><a href="#impl-IntoEither-for-T" title="IntoEither">IntoEither</a></li><li><a href="#impl-MaybeSendSync-for-T" title="MaybeSendSync">MaybeSendSync</a></li><li><a href="#impl-MinOrder%3CT%3E-for-T" title="MinOrder&#60;T&#62;">MinOrder&#60;T&#62;</a></li><li><a href="#impl-Same-for-T" title="Same">Same</a></li><li><a href="#impl-ToOwned-for-T" title="ToOwned">ToOwned</a></li><li><a href="#impl-TryFrom%3CU%3E-for-T" title="TryFrom&#60;U&#62;">TryFrom&#60;U&#62;</a></li><li><a href="#impl-TryInto%3CU%3E-for-T" title="TryInto&#60;U&#62;">TryInto&#60;U&#62;</a></li><li><a href="#impl-VZip%3CV%3E-for-T" title="VZip&#60;V&#62;">VZip&#60;V&#62;</a></li><li><a href="#impl-WithSubscriber-for-T" title="WithSubscriber">WithSubscriber</a></li></ul></section><div id="rustdoc-modnav"><h2><a href="index.html">In hydro_<wbr>lang::<wbr>stream</a></h2></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../index.html">hydro_lang</a>::<wbr><a href="index.html">stream</a></div><h1>Struct <span class="struct">Stream</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../src/hydro_lang/stream.rs.html#70-75">Source</a> </span></div><pre class="rust item-decl"><code>pub struct Stream&lt;T, L, B, Order = <a class="struct" href="struct.TotalOrder.html" title="struct hydro_lang::stream::TotalOrder">TotalOrder</a>&gt; { <span class="comment">/* private fields */</span> }</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>An ordered sequence stream of elements of type <code>T</code>.</p>
<p>Type Parameters:</p>
<ul>
<li><code>T</code>: the type of elements in the stream</li>
<li><code>L</code>: the location where the stream is being materialized</li>
<li><code>B</code>: the boundedness of the stream, which is either <a href="../boundedness/enum.Bounded.html" title="enum hydro_lang::boundedness::Bounded"><code>Bounded</code></a>
or <a href="../boundedness/enum.Unbounded.html" title="enum hydro_lang::boundedness::Unbounded"><code>Unbounded</code></a></li>
<li><code>Order</code>: the ordering of the stream, which is either <a href="struct.TotalOrder.html" title="struct hydro_lang::stream::TotalOrder"><code>TotalOrder</code></a>
or <a href="struct.NoOrder.html" title="struct hydro_lang::stream::NoOrder"><code>NoOrder</code></a> (default is <a href="struct.TotalOrder.html" title="struct hydro_lang::stream::TotalOrder"><code>TotalOrder</code></a>)</li>
</ul>
</div></details><h2 id="implementations" class="section-header">Implementations<a href="#implementations" class="anchor">§</a></h2><div id="implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Stream%3CT,+L,+B,+Order%3E" class="impl"><a class="src rightside" href="../../src/hydro_lang/stream.rs.html#237-715">Source</a><a href="#impl-Stream%3CT,+L,+B,+Order%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a, T, L: <a class="trait" href="../location/trait.Location.html" title="trait hydro_lang::location::Location">Location</a>&lt;'a&gt;, B, Order&gt; <a class="struct" href="struct.Stream.html" title="struct hydro_lang::stream::Stream">Stream</a>&lt;T, L, B, Order&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.map" class="method"><a class="src rightside" href="../../src/hydro_lang/stream.rs.html#255-268">Source</a><h4 class="code-header">pub fn <a href="#method.map" class="fn">map</a>&lt;U, F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(T) -&gt; U + 'a&gt;(
    self,
    f: impl IntoQuotedMut&lt;'a, F, L&gt;,
) -&gt; <a class="struct" href="struct.Stream.html" title="struct hydro_lang::stream::Stream">Stream</a>&lt;U, L, B, Order&gt;</h4></section></summary><div class="docblock"><p>Produces a stream based on invoking <code>f</code> on each element in order.
If you do not want to modify the stream and instead only want to view
each item use <a href="struct.Stream.html#method.inspect" title="method hydro_lang::stream::Stream::inspect"><code>Stream::inspect</code></a> instead.</p>
<h5 id="example"><a class="doc-anchor" href="#example">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>words = process.source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[<span class="string">"hello"</span>, <span class="string">"world"</span>]));
words.map(<span class="macro">q!</span>(|x| x.to_uppercase()))</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.flat_map_ordered" class="method"><a class="src rightside" href="../../src/hydro_lang/stream.rs.html#292-305">Source</a><h4 class="code-header">pub fn <a href="#method.flat_map_ordered" class="fn">flat_map_ordered</a>&lt;U, I: <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&lt;Item = U&gt;, F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(T) -&gt; I + 'a&gt;(
    self,
    f: impl IntoQuotedMut&lt;'a, F, L&gt;,
) -&gt; <a class="struct" href="struct.Stream.html" title="struct hydro_lang::stream::Stream">Stream</a>&lt;U, L, B, Order&gt;</h4></section></summary><div class="docblock"><p>For each item <code>i</code> in the input stream, transform <code>i</code> using <code>f</code> and then treat the
result as an <a href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator"><code>Iterator</code></a> to produce items one by one. The implementation for <a href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator"><code>Iterator</code></a>
for the output type <code>U</code> must produce items in a <strong>deterministic</strong> order.</p>
<p>For example, <code>U</code> could be a <code>Vec</code>, but not a <code>HashSet</code>. If the order of the items in <code>U</code> is
not deterministic, use <a href="struct.Stream.html#method.flat_map_unordered" title="method hydro_lang::stream::Stream::flat_map_unordered"><code>Stream::flat_map_unordered</code></a> instead.</p>
<h5 id="example-1"><a class="doc-anchor" href="#example-1">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>process
    .source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[<span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>], <span class="macro">vec!</span>[<span class="number">3</span>, <span class="number">4</span>]]))
    .flat_map_ordered(<span class="macro">q!</span>(|x| x))
<span class="comment">// 1, 2, 3, 4</span></code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.flat_map_unordered" class="method"><a class="src rightside" href="../../src/hydro_lang/stream.rs.html#331-344">Source</a><h4 class="code-header">pub fn <a href="#method.flat_map_unordered" class="fn">flat_map_unordered</a>&lt;U, I: <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&lt;Item = U&gt;, F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(T) -&gt; I + 'a&gt;(
    self,
    f: impl IntoQuotedMut&lt;'a, F, L&gt;,
) -&gt; <a class="struct" href="struct.Stream.html" title="struct hydro_lang::stream::Stream">Stream</a>&lt;U, L, B, <a class="struct" href="struct.NoOrder.html" title="struct hydro_lang::stream::NoOrder">NoOrder</a>&gt;</h4></section></summary><div class="docblock"><p>Like <a href="struct.Stream.html#method.flat_map_ordered" title="method hydro_lang::stream::Stream::flat_map_ordered"><code>Stream::flat_map_ordered</code></a>, but allows the implementation of <a href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator"><code>Iterator</code></a>
for the output type <code>U</code> to produce items in any order.</p>
<h5 id="example-2"><a class="doc-anchor" href="#example-2">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>process
    .source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[
        std::collections::HashSet::&lt;i32&gt;::from_iter(<span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>]),
        std::collections::HashSet::from_iter(<span class="macro">vec!</span>[<span class="number">3</span>, <span class="number">4</span>]),
    ]))
    .flat_map_unordered(<span class="macro">q!</span>(|x| x))
<span class="comment">// 1, 2, 3, 4, but in no particular order</span></code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.flatten_ordered" class="method"><a class="src rightside" href="../../src/hydro_lang/stream.rs.html#366-371">Source</a><h4 class="code-header">pub fn <a href="#method.flatten_ordered" class="fn">flatten_ordered</a>&lt;U&gt;(self) -&gt; <a class="struct" href="struct.Stream.html" title="struct hydro_lang::stream::Stream">Stream</a>&lt;U, L, B, Order&gt;<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&lt;Item = U&gt;,</div></h4></section></summary><div class="docblock"><p>For each item <code>i</code> in the input stream, treat <code>i</code> as an <a href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator"><code>Iterator</code></a> and produce its items one by one.
The implementation for <a href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator"><code>Iterator</code></a> for the element type <code>T</code> must produce items in a <strong>deterministic</strong> order.</p>
<p>For example, <code>T</code> could be a <code>Vec</code>, but not a <code>HashSet</code>. If the order of the items in <code>T</code> is
not deterministic, use <a href="struct.Stream.html#method.flatten_unordered" title="method hydro_lang::stream::Stream::flatten_unordered"><code>Stream::flatten_unordered</code></a> instead.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>process
    .source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[<span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>], <span class="macro">vec!</span>[<span class="number">3</span>, <span class="number">4</span>]]))
    .flatten_ordered()
<span class="comment">// 1, 2, 3, 4</span></code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.flatten_unordered" class="method"><a class="src rightside" href="../../src/hydro_lang/stream.rs.html#396-401">Source</a><h4 class="code-header">pub fn <a href="#method.flatten_unordered" class="fn">flatten_unordered</a>&lt;U&gt;(self) -&gt; <a class="struct" href="struct.Stream.html" title="struct hydro_lang::stream::Stream">Stream</a>&lt;U, L, B, <a class="struct" href="struct.NoOrder.html" title="struct hydro_lang::stream::NoOrder">NoOrder</a>&gt;<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&lt;Item = U&gt;,</div></h4></section></summary><div class="docblock"><p>Like <a href="struct.Stream.html#method.flatten_ordered" title="method hydro_lang::stream::Stream::flatten_ordered"><code>Stream::flatten_ordered</code></a>, but allows the implementation of <a href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator"><code>Iterator</code></a>
for the element type <code>T</code> to produce items in any order.</p>
<h5 id="example-3"><a class="doc-anchor" href="#example-3">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>process
    .source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[
        std::collections::HashSet::&lt;i32&gt;::from_iter(<span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>]),
        std::collections::HashSet::from_iter(<span class="macro">vec!</span>[<span class="number">3</span>, <span class="number">4</span>]),
    ]))
    .flatten_unordered()
<span class="comment">// 1, 2, 3, 4, but in no particular order</span></code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.filter" class="method"><a class="src rightside" href="../../src/hydro_lang/stream.rs.html#425-438">Source</a><h4 class="code-header">pub fn <a href="#method.filter" class="fn">filter</a>&lt;F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;T</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a> + 'a&gt;(
    self,
    f: impl IntoQuotedMut&lt;'a, F, L&gt;,
) -&gt; <a class="struct" href="struct.Stream.html" title="struct hydro_lang::stream::Stream">Stream</a>&lt;T, L, B, Order&gt;</h4></section></summary><div class="docblock"><p>Creates a stream containing only the elements of the input stream that satisfy a predicate
<code>f</code>, preserving the order of the elements.</p>
<p>The closure <code>f</code> receives a reference <code>&amp;T</code> rather than an owned value <code>T</code> because filtering does
not modify or take ownership of the values. If you need to modify the values while filtering
use <a href="struct.Stream.html#method.filter_map" title="method hydro_lang::stream::Stream::filter_map"><code>Stream::filter_map</code></a> instead.</p>
<h5 id="example-4"><a class="doc-anchor" href="#example-4">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>process
    .source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]))
    .filter(<span class="macro">q!</span>(|<span class="kw-2">&amp;</span>x| x &gt; <span class="number">2</span>))
<span class="comment">// 3, 4</span></code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.filter_map" class="method"><a class="src rightside" href="../../src/hydro_lang/stream.rs.html#456-469">Source</a><h4 class="code-header">pub fn <a href="#method.filter_map" class="fn">filter_map</a>&lt;U, F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(T) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;U&gt; + 'a&gt;(
    self,
    f: impl IntoQuotedMut&lt;'a, F, L&gt;,
) -&gt; <a class="struct" href="struct.Stream.html" title="struct hydro_lang::stream::Stream">Stream</a>&lt;U, L, B, Order&gt;</h4></section></summary><div class="docblock"><p>An operator that both filters and maps. It yields only the items for which the supplied closure <code>f</code> returns <code>Some(value)</code>.</p>
<h5 id="example-5"><a class="doc-anchor" href="#example-5">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>process
    .source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[<span class="string">"1"</span>, <span class="string">"hello"</span>, <span class="string">"world"</span>, <span class="string">"2"</span>]))
    .filter_map(<span class="macro">q!</span>(|s| s.parse::&lt;usize&gt;().ok()))
<span class="comment">// 1, 2</span></code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.cross_singleton" class="method"><a class="src rightside" href="../../src/hydro_lang/stream.rs.html#493-511">Source</a><h4 class="code-header">pub fn <a href="#method.cross_singleton" class="fn">cross_singleton</a>&lt;O&gt;(
    self,
    other: impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="struct" href="../optional/struct.Optional.html" title="struct hydro_lang::optional::Optional">Optional</a>&lt;O, L, <a class="enum" href="../boundedness/enum.Bounded.html" title="enum hydro_lang::boundedness::Bounded">Bounded</a>&gt;&gt;,
) -&gt; <a class="struct" href="struct.Stream.html" title="struct hydro_lang::stream::Stream">Stream</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">(T, O)</a>, L, B, Order&gt;<div class="where">where
    O: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</div></h4></section></summary><div class="docblock"><p>Generates a stream that maps each input element <code>i</code> to a tuple <code>(i, x)</code>,
where <code>x</code> is the final value of <code>other</code>, a bounded <a href="../singleton/struct.Singleton.html" title="struct hydro_lang::singleton::Singleton"><code>Singleton</code></a>.</p>
<h5 id="example-6"><a class="doc-anchor" href="#example-6">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>tick = process.tick();
<span class="kw">let </span>batch = <span class="kw">unsafe </span>{
    process
        .source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]))
        .tick_batch(<span class="kw-2">&amp;</span>tick)
};
<span class="kw">let </span>count = batch.clone().count(); <span class="comment">// `count()` returns a singleton
</span>batch.cross_singleton(count).all_ticks()
<span class="comment">// (1, 4), (2, 4), (3, 4), (4, 4)</span></code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.continue_if" class="method"><a class="src rightside" href="../../src/hydro_lang/stream.rs.html#514-517">Source</a><h4 class="code-header">pub fn <a href="#method.continue_if" class="fn">continue_if</a>&lt;U&gt;(
    self,
    signal: <a class="struct" href="../optional/struct.Optional.html" title="struct hydro_lang::optional::Optional">Optional</a>&lt;U, L, <a class="enum" href="../boundedness/enum.Bounded.html" title="enum hydro_lang::boundedness::Bounded">Bounded</a>&gt;,
) -&gt; <a class="struct" href="struct.Stream.html" title="struct hydro_lang::stream::Stream">Stream</a>&lt;T, L, B, Order&gt;</h4></section></summary><div class="docblock"><p>Allow this stream through if the argument (a Bounded Optional) is non-empty, otherwise the output is empty.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.continue_unless" class="method"><a class="src rightside" href="../../src/hydro_lang/stream.rs.html#520-522">Source</a><h4 class="code-header">pub fn <a href="#method.continue_unless" class="fn">continue_unless</a>&lt;U&gt;(
    self,
    other: <a class="struct" href="../optional/struct.Optional.html" title="struct hydro_lang::optional::Optional">Optional</a>&lt;U, L, <a class="enum" href="../boundedness/enum.Bounded.html" title="enum hydro_lang::boundedness::Bounded">Bounded</a>&gt;,
) -&gt; <a class="struct" href="struct.Stream.html" title="struct hydro_lang::stream::Stream">Stream</a>&lt;T, L, B, Order&gt;</h4></section></summary><div class="docblock"><p>Allow this stream through if the argument (a Bounded Optional) is empty, otherwise the output is empty.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.cross_product" class="method"><a class="src rightside" href="../../src/hydro_lang/stream.rs.html#541-556">Source</a><h4 class="code-header">pub fn <a href="#method.cross_product" class="fn">cross_product</a>&lt;O&gt;(
    self,
    other: <a class="struct" href="struct.Stream.html" title="struct hydro_lang::stream::Stream">Stream</a>&lt;O, L, B, Order&gt;,
) -&gt; <a class="struct" href="struct.Stream.html" title="struct hydro_lang::stream::Stream">Stream</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">(T, O)</a>, L, B, <a class="struct" href="struct.NoOrder.html" title="struct hydro_lang::stream::NoOrder">NoOrder</a>&gt;<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,
    O: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</div></h4></section></summary><div class="docblock"><p>Forms the cross-product (Cartesian product, cross-join) of the items in the 2 input streams, returning all
tupled pairs in a non-deterministic order.</p>
<h5 id="example-7"><a class="doc-anchor" href="#example-7">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>tick = process.tick();
<span class="kw">let </span>stream1 = process.source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]));
<span class="kw">let </span>stream2 = process.source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]));
stream1.cross_product(stream2)</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.unique" class="method"><a class="src rightside" href="../../src/hydro_lang/stream.rs.html#573-584">Source</a><h4 class="code-header">pub fn <a href="#method.unique" class="fn">unique</a>(self) -&gt; <a class="struct" href="struct.Stream.html" title="struct hydro_lang::stream::Stream">Stream</a>&lt;T, L, B, Order&gt;<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html" title="trait core::hash::Hash">Hash</a>,</div></h4></section></summary><div class="docblock"><p>Takes one stream as input and filters out any duplicate occurrences. The output
contains all unique values from the input.</p>
<h5 id="example-8"><a class="doc-anchor" href="#example-8">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>tick = process.tick();
    process.source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>])).unique()</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.filter_not_in" class="method"><a class="src rightside" href="../../src/hydro_lang/stream.rs.html#612-626">Source</a><h4 class="code-header">pub fn <a href="#method.filter_not_in" class="fn">filter_not_in</a>&lt;O2&gt;(
    self,
    other: <a class="struct" href="struct.Stream.html" title="struct hydro_lang::stream::Stream">Stream</a>&lt;T, L, <a class="enum" href="../boundedness/enum.Bounded.html" title="enum hydro_lang::boundedness::Bounded">Bounded</a>, O2&gt;,
) -&gt; <a class="struct" href="struct.Stream.html" title="struct hydro_lang::stream::Stream">Stream</a>&lt;T, L, <a class="enum" href="../boundedness/enum.Bounded.html" title="enum hydro_lang::boundedness::Bounded">Bounded</a>, Order&gt;<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html" title="trait core::hash::Hash">Hash</a>,</div></h4></section></summary><div class="docblock"><p>Outputs everything in this stream that is <em>not</em> contained in the <code>other</code> stream.</p>
<p>The <code>other</code> stream must be <a href="../boundedness/enum.Bounded.html" title="enum hydro_lang::boundedness::Bounded"><code>Bounded</code></a>, since this function will wait until
all its elements are available before producing any output.</p>
<h5 id="example-9"><a class="doc-anchor" href="#example-9">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>tick = process.tick();
<span class="kw">let </span>stream = <span class="kw">unsafe </span>{
   process
   .source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4 </span>]))
   .tick_batch(<span class="kw-2">&amp;</span>tick)
};
<span class="kw">let </span>batch = <span class="kw">unsafe </span>{
    process
        .source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>]))
        .tick_batch(<span class="kw-2">&amp;</span>tick)
};
stream.filter_not_in(batch).all_ticks()</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.inspect" class="method"><a class="src rightside" href="../../src/hydro_lang/stream.rs.html#646-677">Source</a><h4 class="code-header">pub fn <a href="#method.inspect" class="fn">inspect</a>&lt;F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;T</a>) + 'a&gt;(
    self,
    f: impl IntoQuotedMut&lt;'a, F, L&gt;,
) -&gt; <a class="struct" href="struct.Stream.html" title="struct hydro_lang::stream::Stream">Stream</a>&lt;T, L, B, Order&gt;</h4></section></summary><div class="docblock"><p>An operator which allows you to “inspect” each element of a stream without
modifying it. The closure <code>f</code> is called on a reference to each item. This is
mainly useful for debugging, and should not be used to generate side-effects.</p>
<h5 id="example-10"><a class="doc-anchor" href="#example-10">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>nums = process.source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>]));
<span class="comment">// prints "1 * 10 = 10" and "2 * 10 = 20"
</span>nums.inspect(<span class="macro">q!</span>(|x| <span class="macro">println!</span>(<span class="string">"{} * 10 = {}"</span>, x, x * <span class="number">10</span>)))</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.assume_ordering" class="method"><a class="src rightside" href="../../src/hydro_lang/stream.rs.html#712-714">Source</a><h4 class="code-header">pub unsafe fn <a href="#method.assume_ordering" class="fn">assume_ordering</a>&lt;O&gt;(self) -&gt; <a class="struct" href="struct.Stream.html" title="struct hydro_lang::stream::Stream">Stream</a>&lt;T, L, B, O&gt;</h4></section></summary><div class="docblock"><p>Explicitly “casts” the stream to a type with a different ordering
guarantee. Useful in unsafe code where the ordering cannot be proven
by the type-system.</p>
<h5 id="safety"><a class="doc-anchor" href="#safety">§</a>Safety</h5>
<p>This function is used as an escape hatch, and any mistakes in the
provided ordering guarantee will propagate into the guarantees
for the rest of the program.</p>
<h5 id="example-11"><a class="doc-anchor" href="#example-11">§</a>Example</h5><h5 id="todo-more-sensible-code-after-shadaj-merges"><a class="doc-anchor" href="#todo-more-sensible-code-after-shadaj-merges">§</a>TODO: more sensible code after Shadaj merges</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>nums = process.source_iter(<span class="macro">q!</span>({
    <span class="kw">let </span>now = std::time::SystemTime::now();
    <span class="kw">match </span>now.elapsed().unwrap().as_secs() % <span class="number">2 </span>{
        <span class="number">0 </span>=&gt; <span class="macro">vec!</span>[<span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>],
        <span class="kw">_ </span>=&gt; <span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>],
    }
    .into_iter()
}));
<span class="comment">// despite being generated by `source_iter`, the order of `nums` across runs is non-deterministic
</span><span class="kw">let </span>stream = <span class="kw">unsafe </span>{ nums.assume_ordering::&lt;NoOrder&gt;() };
stream</code></pre></div>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Stream%3C%26T,+L,+B,+Order%3E" class="impl"><a class="src rightside" href="../../src/hydro_lang/stream.rs.html#717-739">Source</a><a href="#impl-Stream%3C%26T,+L,+B,+Order%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a, T, L: <a class="trait" href="../location/trait.Location.html" title="trait hydro_lang::location::Location">Location</a>&lt;'a&gt;, B, Order&gt; <a class="struct" href="struct.Stream.html" title="struct hydro_lang::stream::Stream">Stream</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;T</a>, L, B, Order&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.cloned" class="method"><a class="src rightside" href="../../src/hydro_lang/stream.rs.html#733-738">Source</a><h4 class="code-header">pub fn <a href="#method.cloned" class="fn">cloned</a>(self) -&gt; <a class="struct" href="struct.Stream.html" title="struct hydro_lang::stream::Stream">Stream</a>&lt;T, L, B, Order&gt;<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</div></h4></section></summary><div class="docblock"><p>Clone each element of the stream; akin to <code>map(q!(|d| d.clone()))</code>.</p>
<h5 id="example-12"><a class="doc-anchor" href="#example-12">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>process.source_iter(<span class="macro">q!</span>(<span class="kw-2">&amp;</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])).cloned()
<span class="comment">// 1, 2, 3</span></code></pre></div>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Stream%3CT,+L,+B,+Order%3E-1" class="impl"><a class="src rightside" href="../../src/hydro_lang/stream.rs.html#741-963">Source</a><a href="#impl-Stream%3CT,+L,+B,+Order%3E-1" class="anchor">§</a><h3 class="code-header">impl&lt;'a, T, L: <a class="trait" href="../location/trait.Location.html" title="trait hydro_lang::location::Location">Location</a>&lt;'a&gt;, B, Order&gt; <a class="struct" href="struct.Stream.html" title="struct hydro_lang::stream::Stream">Stream</a>&lt;T, L, B, Order&gt;<div class="where">where
    Order: <a class="trait" href="trait.MinOrder.html" title="trait hydro_lang::stream::MinOrder">MinOrder</a>&lt;<a class="struct" href="struct.NoOrder.html" title="struct hydro_lang::stream::NoOrder">NoOrder</a>, Min = <a class="struct" href="struct.NoOrder.html" title="struct hydro_lang::stream::NoOrder">NoOrder</a>&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fold_commutative" class="method"><a class="src rightside" href="../../src/hydro_lang/stream.rs.html#767-793">Source</a><h4 class="code-header">pub fn <a href="#method.fold_commutative" class="fn">fold_commutative</a>&lt;A, I: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>() -&gt; A + 'a, F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut A</a>, T)&gt;(
    self,
    init: impl IntoQuotedMut&lt;'a, I, L&gt;,
    comb: impl IntoQuotedMut&lt;'a, F, L&gt;,
) -&gt; <a class="struct" href="../singleton/struct.Singleton.html" title="struct hydro_lang::singleton::Singleton">Singleton</a>&lt;A, L, B&gt;</h4></section></summary><div class="docblock"><p>Combines elements of the stream into a <a href="../singleton/struct.Singleton.html" title="struct hydro_lang::singleton::Singleton"><code>Singleton</code></a>, by starting with an initial value,
generated by the <code>init</code> closure, and then applying the <code>comb</code> closure to each element in the stream.
Unlike iterators, <code>comb</code> takes the accumulator by <code>&amp;mut</code> reference, so that it can be modified in place.</p>
<p>The <code>comb</code> closure must be <strong>commutative</strong>, as the order of input items is not guaranteed.</p>
<h5 id="example-13"><a class="doc-anchor" href="#example-13">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>tick = process.tick();
<span class="kw">let </span>numbers = process.source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]));
<span class="kw">let </span>batch = <span class="kw">unsafe </span>{ numbers.tick_batch(<span class="kw-2">&amp;</span>tick) };
batch
    .fold_commutative(<span class="macro">q!</span>(|| <span class="number">0</span>), <span class="macro">q!</span>(|acc, x| <span class="kw-2">*</span>acc += x))
    .all_ticks()
<span class="comment">// 10</span></code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.reduce_commutative" class="method"><a class="src rightside" href="../../src/hydro_lang/stream.rs.html#818-837">Source</a><h4 class="code-header">pub fn <a href="#method.reduce_commutative" class="fn">reduce_commutative</a>&lt;F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut T</a>, T) + 'a&gt;(
    self,
    comb: impl IntoQuotedMut&lt;'a, F, L&gt;,
) -&gt; <a class="struct" href="../optional/struct.Optional.html" title="struct hydro_lang::optional::Optional">Optional</a>&lt;T, L, B&gt;</h4></section></summary><div class="docblock"><p>Combines elements of the stream into a <a href="../optional/struct.Optional.html" title="struct hydro_lang::optional::Optional"><code>Optional</code></a>, by starting with the first element in the stream,
and then applying the <code>comb</code> closure to each element in the stream. The <a href="../optional/struct.Optional.html" title="struct hydro_lang::optional::Optional"><code>Optional</code></a> will be empty
until the first element in the input arrives. Unlike iterators, <code>comb</code> takes the accumulator by <code>&amp;mut</code>
reference, so that it can be modified in place.</p>
<p>The <code>comb</code> closure must be <strong>commutative</strong>, as the order of input items is not guaranteed.</p>
<h5 id="example-14"><a class="doc-anchor" href="#example-14">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>tick = process.tick();
<span class="kw">let </span>numbers = process.source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]));
<span class="kw">let </span>batch = <span class="kw">unsafe </span>{ numbers.tick_batch(<span class="kw-2">&amp;</span>tick) };
batch
    .reduce_commutative(<span class="macro">q!</span>(|curr, new| <span class="kw-2">*</span>curr += new))
    .all_ticks()
<span class="comment">// 10</span></code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.max" class="method"><a class="src rightside" href="../../src/hydro_lang/stream.rs.html#856-865">Source</a><h4 class="code-header">pub fn <a href="#method.max" class="fn">max</a>(self) -&gt; <a class="struct" href="../optional/struct.Optional.html" title="struct hydro_lang::optional::Optional">Optional</a>&lt;T, L, B&gt;<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.Ord.html" title="trait core::cmp::Ord">Ord</a>,</div></h4></section></summary><div class="docblock"><p>Computes the maximum element in the stream as an <a href="../optional/struct.Optional.html" title="struct hydro_lang::optional::Optional"><code>Optional</code></a>, which
will be empty until the first element in the input arrives.</p>
<h5 id="example-15"><a class="doc-anchor" href="#example-15">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>tick = process.tick();
<span class="kw">let </span>numbers = process.source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]));
<span class="kw">let </span>batch = <span class="kw">unsafe </span>{ numbers.tick_batch(<span class="kw-2">&amp;</span>tick) };
batch.max().all_ticks()
<span class="comment">// 4</span></code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.max_by_key" class="method"><a class="src rightside" href="../../src/hydro_lang/stream.rs.html#885-914">Source</a><h4 class="code-header">pub fn <a href="#method.max_by_key" class="fn">max_by_key</a>&lt;K: <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.Ord.html" title="trait core::cmp::Ord">Ord</a>, F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;T</a>) -&gt; K + 'a&gt;(
    self,
    key: impl IntoQuotedMut&lt;'a, F, L&gt; + <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Copy.html" title="trait core::marker::Copy">Copy</a>,
) -&gt; <a class="struct" href="../optional/struct.Optional.html" title="struct hydro_lang::optional::Optional">Optional</a>&lt;T, L, B&gt;</h4></section></summary><div class="docblock"><p>Computes the maximum element in the stream as an <a href="../optional/struct.Optional.html" title="struct hydro_lang::optional::Optional"><code>Optional</code></a>, where the
maximum is determined according to the <code>key</code> function. The <a href="../optional/struct.Optional.html" title="struct hydro_lang::optional::Optional"><code>Optional</code></a> will
be empty until the first element in the input arrives.</p>
<h5 id="example-16"><a class="doc-anchor" href="#example-16">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>tick = process.tick();
<span class="kw">let </span>numbers = process.source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]));
<span class="kw">let </span>batch = <span class="kw">unsafe </span>{ numbers.tick_batch(<span class="kw-2">&amp;</span>tick) };
batch.max_by_key(<span class="macro">q!</span>(|x| -x)).all_ticks()
<span class="comment">// 1</span></code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.min" class="method"><a class="src rightside" href="../../src/hydro_lang/stream.rs.html#933-942">Source</a><h4 class="code-header">pub fn <a href="#method.min" class="fn">min</a>(self) -&gt; <a class="struct" href="../optional/struct.Optional.html" title="struct hydro_lang::optional::Optional">Optional</a>&lt;T, L, B&gt;<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.Ord.html" title="trait core::cmp::Ord">Ord</a>,</div></h4></section></summary><div class="docblock"><p>Computes the minimum element in the stream as an <a href="../optional/struct.Optional.html" title="struct hydro_lang::optional::Optional"><code>Optional</code></a>, which
will be empty until the first element in the input arrives.</p>
<h5 id="example-17"><a class="doc-anchor" href="#example-17">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>tick = process.tick();
<span class="kw">let </span>numbers = process.source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]));
<span class="kw">let </span>batch = <span class="kw">unsafe </span>{ numbers.tick_batch(<span class="kw-2">&amp;</span>tick) };
batch.min().all_ticks()
<span class="comment">// 1</span></code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.count" class="method"><a class="src rightside" href="../../src/hydro_lang/stream.rs.html#960-962">Source</a><h4 class="code-header">pub fn <a href="#method.count" class="fn">count</a>(self) -&gt; <a class="struct" href="../singleton/struct.Singleton.html" title="struct hydro_lang::singleton::Singleton">Singleton</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>, L, B&gt;</h4></section></summary><div class="docblock"><p>Computes the number of elements in the stream as a <a href="../singleton/struct.Singleton.html" title="struct hydro_lang::singleton::Singleton"><code>Singleton</code></a>.</p>
<h5 id="example-18"><a class="doc-anchor" href="#example-18">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>tick = process.tick();
<span class="kw">let </span>numbers = process.source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]));
<span class="kw">let </span>batch = <span class="kw">unsafe </span>{ numbers.tick_batch(<span class="kw-2">&amp;</span>tick) };
batch.count().all_ticks()
<span class="comment">// 4</span></code></pre></div>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Stream%3CT,+L,+B%3E" class="impl"><a class="src rightside" href="../../src/hydro_lang/stream.rs.html#965-1154">Source</a><a href="#impl-Stream%3CT,+L,+B%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a, T, L: <a class="trait" href="../location/trait.Location.html" title="trait hydro_lang::location::Location">Location</a>&lt;'a&gt;, B&gt; <a class="struct" href="struct.Stream.html" title="struct hydro_lang::stream::Stream">Stream</a>&lt;T, L, B, <a class="struct" href="struct.TotalOrder.html" title="struct hydro_lang::stream::TotalOrder">TotalOrder</a>&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.enumerate" class="method"><a class="src rightside" href="../../src/hydro_lang/stream.rs.html#983-1009">Source</a><h4 class="code-header">pub fn <a href="#method.enumerate" class="fn">enumerate</a>(self) -&gt; <a class="struct" href="struct.Stream.html" title="struct hydro_lang::stream::Stream">Stream</a>&lt;(<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>, T), L, B, <a class="struct" href="struct.TotalOrder.html" title="struct hydro_lang::stream::TotalOrder">TotalOrder</a>&gt;</h4></section></summary><div class="docblock"><p>Returns a stream with the current count tupled with each element in the input stream.</p>
<h5 id="example-19"><a class="doc-anchor" href="#example-19">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>tick = process.tick();
<span class="kw">let </span>numbers = process.source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]));
numbers.enumerate()
<span class="comment">// (0, 1), (1, 2), (2, 3), (3, 4)</span></code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.first" class="method"><a class="src rightside" href="../../src/hydro_lang/stream.rs.html#1031-1033">Source</a><h4 class="code-header">pub fn <a href="#method.first" class="fn">first</a>(self) -&gt; <a class="struct" href="../optional/struct.Optional.html" title="struct hydro_lang::optional::Optional">Optional</a>&lt;T, L, B&gt;</h4></section></summary><div class="docblock"><p>Computes the first element in the stream as an <a href="../optional/struct.Optional.html" title="struct hydro_lang::optional::Optional"><code>Optional</code></a>, which
will be empty until the first element in the input arrives.</p>
<p>This requires the stream to have a <a href="struct.TotalOrder.html" title="struct hydro_lang::stream::TotalOrder"><code>TotalOrder</code></a> guarantee, otherwise
re-ordering of elements may cause the first element to change.</p>
<h5 id="example-20"><a class="doc-anchor" href="#example-20">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>tick = process.tick();
<span class="kw">let </span>numbers = process.source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]));
<span class="kw">let </span>batch = <span class="kw">unsafe </span>{ numbers.tick_batch(<span class="kw-2">&amp;</span>tick) };
batch.first().all_ticks()
<span class="comment">// 1</span></code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.last" class="method"><a class="src rightside" href="../../src/hydro_lang/stream.rs.html#1055-1057">Source</a><h4 class="code-header">pub fn <a href="#method.last" class="fn">last</a>(self) -&gt; <a class="struct" href="../optional/struct.Optional.html" title="struct hydro_lang::optional::Optional">Optional</a>&lt;T, L, B&gt;</h4></section></summary><div class="docblock"><p>Computes the last element in the stream as an <a href="../optional/struct.Optional.html" title="struct hydro_lang::optional::Optional"><code>Optional</code></a>, which
will be empty until an element in the input arrives.</p>
<p>This requires the stream to have a <a href="struct.TotalOrder.html" title="struct hydro_lang::stream::TotalOrder"><code>TotalOrder</code></a> guarantee, otherwise
re-ordering of elements may cause the last element to change.</p>
<h5 id="example-21"><a class="doc-anchor" href="#example-21">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>tick = process.tick();
<span class="kw">let </span>numbers = process.source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]));
<span class="kw">let </span>batch = <span class="kw">unsafe </span>{ numbers.tick_batch(<span class="kw-2">&amp;</span>tick) };
batch.last().all_ticks()
<span class="comment">// 4</span></code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.fold" class="method"><a class="src rightside" href="../../src/hydro_lang/stream.rs.html#1082-1108">Source</a><h4 class="code-header">pub fn <a href="#method.fold" class="fn">fold</a>&lt;A, I: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>() -&gt; A + 'a, F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut A</a>, T)&gt;(
    self,
    init: impl IntoQuotedMut&lt;'a, I, L&gt;,
    comb: impl IntoQuotedMut&lt;'a, F, L&gt;,
) -&gt; <a class="struct" href="../singleton/struct.Singleton.html" title="struct hydro_lang::singleton::Singleton">Singleton</a>&lt;A, L, B&gt;</h4></section></summary><div class="docblock"><p>Combines elements of the stream into a <a href="../singleton/struct.Singleton.html" title="struct hydro_lang::singleton::Singleton"><code>Singleton</code></a>, by starting with an intitial value,
generated by the <code>init</code> closure, and then applying the <code>comb</code> closure to each element in the stream.
Unlike iterators, <code>comb</code> takes the accumulator by <code>&amp;mut</code> reference, so that it can be modified in place.</p>
<p>The input stream must have a <a href="struct.TotalOrder.html" title="struct hydro_lang::stream::TotalOrder"><code>TotalOrder</code></a> guarantee, which means that the <code>comb</code> closure is allowed
to depend on the order of elements in the stream.</p>
<h5 id="example-22"><a class="doc-anchor" href="#example-22">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>tick = process.tick();
<span class="kw">let </span>words = process.source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[<span class="string">"HELLO"</span>, <span class="string">"WORLD"</span>]));
<span class="kw">let </span>batch = <span class="kw">unsafe </span>{ words.tick_batch(<span class="kw-2">&amp;</span>tick) };
batch
    .fold(<span class="macro">q!</span>(|| String::new()), <span class="macro">q!</span>(|acc, x| acc.push_str(x)))
    .all_ticks()
<span class="comment">// "HELLOWORLD"</span></code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.reduce" class="method"><a class="src rightside" href="../../src/hydro_lang/stream.rs.html#1134-1153">Source</a><h4 class="code-header">pub fn <a href="#method.reduce" class="fn">reduce</a>&lt;F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut T</a>, T) + 'a&gt;(
    self,
    comb: impl IntoQuotedMut&lt;'a, F, L&gt;,
) -&gt; <a class="struct" href="../optional/struct.Optional.html" title="struct hydro_lang::optional::Optional">Optional</a>&lt;T, L, B&gt;</h4></section></summary><div class="docblock"><p>Combines elements of the stream into an <a href="../optional/struct.Optional.html" title="struct hydro_lang::optional::Optional"><code>Optional</code></a>, by starting with the first element in the stream,
and then applying the <code>comb</code> closure to each element in the stream. The <a href="../optional/struct.Optional.html" title="struct hydro_lang::optional::Optional"><code>Optional</code></a> will be empty
until the first element in the input arrives.</p>
<p>The input stream must have a <a href="struct.TotalOrder.html" title="struct hydro_lang::stream::TotalOrder"><code>TotalOrder</code></a> guarantee, which means that the <code>comb</code> closure is allowed
to depend on the order of elements in the stream.</p>
<h5 id="example-23"><a class="doc-anchor" href="#example-23">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>tick = process.tick();
<span class="kw">let </span>words = process.source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[<span class="string">"HELLO"</span>, <span class="string">"WORLD"</span>]));
<span class="kw">let </span>batch = <span class="kw">unsafe </span>{ words.tick_batch(<span class="kw-2">&amp;</span>tick) };
batch
    .map(<span class="macro">q!</span>(|x| x.to_string()))
    .reduce(<span class="macro">q!</span>(|curr, new| curr.push_str(<span class="kw-2">&amp;</span>new)))
    .all_ticks()
<span class="comment">// "HELLOWORLD"</span></code></pre></div>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Stream%3CT,+L,+Unbounded,+O%3E" class="impl"><a class="src rightside" href="../../src/hydro_lang/stream.rs.html#1156-1189">Source</a><a href="#impl-Stream%3CT,+L,+Unbounded,+O%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a, T, L: <a class="trait" href="../location/trait.Location.html" title="trait hydro_lang::location::Location">Location</a>&lt;'a&gt; + <a class="trait" href="../location/tick/trait.NoTick.html" title="trait hydro_lang::location::tick::NoTick">NoTick</a> + <a class="trait" href="../location/tick/trait.NoAtomic.html" title="trait hydro_lang::location::tick::NoAtomic">NoAtomic</a>, O&gt; <a class="struct" href="struct.Stream.html" title="struct hydro_lang::stream::Stream">Stream</a>&lt;T, L, <a class="enum" href="../boundedness/enum.Unbounded.html" title="enum hydro_lang::boundedness::Unbounded">Unbounded</a>, O&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.union" class="method"><a class="src rightside" href="../../src/hydro_lang/stream.rs.html#1177-1188">Source</a><h4 class="code-header">pub fn <a href="#method.union" class="fn">union</a>&lt;O2&gt;(
    self,
    other: <a class="struct" href="struct.Stream.html" title="struct hydro_lang::stream::Stream">Stream</a>&lt;T, L, <a class="enum" href="../boundedness/enum.Unbounded.html" title="enum hydro_lang::boundedness::Unbounded">Unbounded</a>, O2&gt;,
) -&gt; <a class="struct" href="struct.Stream.html" title="struct hydro_lang::stream::Stream">Stream</a>&lt;T, L, <a class="enum" href="../boundedness/enum.Unbounded.html" title="enum hydro_lang::boundedness::Unbounded">Unbounded</a>, <a class="struct" href="struct.NoOrder.html" title="struct hydro_lang::stream::NoOrder">NoOrder</a>&gt;</h4></section></summary><div class="docblock"><p>Produces a new stream that interleaves the elements of the two input streams.
The result has <a href="struct.NoOrder.html" title="struct hydro_lang::stream::NoOrder"><code>NoOrder</code></a> because the order of interleaving is not guaranteed.</p>
<p>Currently, both input streams must be <a href="../boundedness/enum.Unbounded.html" title="enum hydro_lang::boundedness::Unbounded"><code>Unbounded</code></a>. When the streams are
<a href="../boundedness/enum.Bounded.html" title="enum hydro_lang::boundedness::Bounded"><code>Bounded</code></a>, you can use <a href="struct.Stream.html#method.chain" title="method hydro_lang::stream::Stream::chain"><code>Stream::chain</code></a> instead.</p>
<h5 id="example-24"><a class="doc-anchor" href="#example-24">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>numbers = process.source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]));
numbers.clone().map(<span class="macro">q!</span>(|x| x + <span class="number">1</span>)).union(numbers)
<span class="comment">// 2, 3, 4, 5, and 1, 2, 3, 4 interleaved in unknown order</span></code></pre></div>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Stream%3CT,+L,+Bounded,+Order%3E" class="impl"><a class="src rightside" href="../../src/hydro_lang/stream.rs.html#1191-1268">Source</a><a href="#impl-Stream%3CT,+L,+Bounded,+Order%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a, T, L: <a class="trait" href="../location/trait.Location.html" title="trait hydro_lang::location::Location">Location</a>&lt;'a&gt;, Order&gt; <a class="struct" href="struct.Stream.html" title="struct hydro_lang::stream::Stream">Stream</a>&lt;T, L, <a class="enum" href="../boundedness/enum.Bounded.html" title="enum hydro_lang::boundedness::Bounded">Bounded</a>, Order&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.sort" class="method"><a class="src rightside" href="../../src/hydro_lang/stream.rs.html#1215-1226">Source</a><h4 class="code-header">pub fn <a href="#method.sort" class="fn">sort</a>(self) -&gt; <a class="struct" href="struct.Stream.html" title="struct hydro_lang::stream::Stream">Stream</a>&lt;T, L, <a class="enum" href="../boundedness/enum.Bounded.html" title="enum hydro_lang::boundedness::Bounded">Bounded</a>, <a class="struct" href="struct.TotalOrder.html" title="struct hydro_lang::stream::TotalOrder">TotalOrder</a>&gt;<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.Ord.html" title="trait core::cmp::Ord">Ord</a>,</div></h4></section></summary><div class="docblock"><p>Produces a new stream that emits the input elements in sorted order.</p>
<p>The input stream can have any ordering guarantee, but the output stream
will have a <a href="struct.TotalOrder.html" title="struct hydro_lang::stream::TotalOrder"><code>TotalOrder</code></a> guarantee. This operator will block until all
elements in the input stream are available, so it requires the input stream
to be <a href="../boundedness/enum.Bounded.html" title="enum hydro_lang::boundedness::Bounded"><code>Bounded</code></a>.</p>
<h5 id="example-25"><a class="doc-anchor" href="#example-25">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>tick = process.tick();
<span class="kw">let </span>numbers = process.source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[<span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>]));
<span class="kw">let </span>batch = <span class="kw">unsafe </span>{ numbers.tick_batch(<span class="kw-2">&amp;</span>tick) };
batch.sort().all_ticks()
<span class="comment">// 1, 2, 3, 4</span></code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.chain" class="method"><a class="src rightside" href="../../src/hydro_lang/stream.rs.html#1253-1267">Source</a><h4 class="code-header">pub fn <a href="#method.chain" class="fn">chain</a>&lt;O2&gt;(
    self,
    other: <a class="struct" href="struct.Stream.html" title="struct hydro_lang::stream::Stream">Stream</a>&lt;T, L, <a class="enum" href="../boundedness/enum.Bounded.html" title="enum hydro_lang::boundedness::Bounded">Bounded</a>, O2&gt;,
) -&gt; <a class="struct" href="struct.Stream.html" title="struct hydro_lang::stream::Stream">Stream</a>&lt;T, L, <a class="enum" href="../boundedness/enum.Bounded.html" title="enum hydro_lang::boundedness::Bounded">Bounded</a>, Order::<a class="associatedtype" href="trait.MinOrder.html#associatedtype.Min" title="type hydro_lang::stream::MinOrder::Min">Min</a>&gt;<div class="where">where
    Order: <a class="trait" href="trait.MinOrder.html" title="trait hydro_lang::stream::MinOrder">MinOrder</a>&lt;O2&gt;,</div></h4></section></summary><div class="docblock"><p>Produces a new stream that first emits the elements of the <code>self</code> stream,
and then emits the elements of the <code>other</code> stream. The output stream has
a <a href="struct.TotalOrder.html" title="struct hydro_lang::stream::TotalOrder"><code>TotalOrder</code></a> guarantee if and only if both input streams have a
<a href="struct.TotalOrder.html" title="struct hydro_lang::stream::TotalOrder"><code>TotalOrder</code></a> guarantee.</p>
<p>Currently, both input streams must be <a href="../boundedness/enum.Bounded.html" title="enum hydro_lang::boundedness::Bounded"><code>Bounded</code></a>. This operator will block
on the first stream until all its elements are available. In a future version,
we will relax the requirement on the <code>other</code> stream.</p>
<h5 id="example-26"><a class="doc-anchor" href="#example-26">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>tick = process.tick();
<span class="kw">let </span>numbers = process.source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]));
<span class="kw">let </span>batch = <span class="kw">unsafe </span>{ numbers.tick_batch(<span class="kw-2">&amp;</span>tick) };
batch.clone().map(<span class="macro">q!</span>(|x| x + <span class="number">1</span>)).chain(batch).all_ticks()
<span class="comment">// 2, 3, 4, 5, 1, 2, 3, 4</span></code></pre></div>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Stream%3C(K,+V1),+L,+B,+Order%3E" class="impl"><a class="src rightside" href="../../src/hydro_lang/stream.rs.html#1270-1347">Source</a><a href="#impl-Stream%3C(K,+V1),+L,+B,+Order%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a, K, V1, L: <a class="trait" href="../location/trait.Location.html" title="trait hydro_lang::location::Location">Location</a>&lt;'a&gt;, B, Order&gt; <a class="struct" href="struct.Stream.html" title="struct hydro_lang::stream::Stream">Stream</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">(K, V1)</a>, L, B, Order&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.join" class="method"><a class="src rightside" href="../../src/hydro_lang/stream.rs.html#1289-1303">Source</a><h4 class="code-header">pub fn <a href="#method.join" class="fn">join</a>&lt;V2, O2&gt;(
    self,
    n: <a class="struct" href="struct.Stream.html" title="struct hydro_lang::stream::Stream">Stream</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">(K, V2)</a>, L, B, O2&gt;,
) -&gt; <a class="struct" href="struct.Stream.html" title="struct hydro_lang::stream::Stream">Stream</a>&lt;(K, <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">(V1, V2)</a>), L, B, <a class="struct" href="struct.NoOrder.html" title="struct hydro_lang::stream::NoOrder">NoOrder</a>&gt;<div class="where">where
    K: <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html" title="trait core::hash::Hash">Hash</a>,</div></h4></section></summary><div class="docblock"><p>Given two streams of pairs <code>(K, V1)</code> and <code>(K, V2)</code>, produces a new stream of nested pairs <code>(K, (V1, V2))</code>
by equi-joining the two streams on the key attribute <code>K</code>.</p>
<h5 id="example-27"><a class="doc-anchor" href="#example-27">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>tick = process.tick();
<span class="kw">let </span>stream1 = process.source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[(<span class="number">1</span>, <span class="string">'a'</span>), (<span class="number">2</span>, <span class="string">'b'</span>)]));
<span class="kw">let </span>stream2 = process.source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[(<span class="number">1</span>, <span class="string">'x'</span>), (<span class="number">2</span>, <span class="string">'y'</span>)]));
stream1.join(stream2)
<span class="comment">// (1, ('a', 'x')), (2, ('b', 'y'))</span></code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.anti_join" class="method"><a class="src rightside" href="../../src/hydro_lang/stream.rs.html#1332-1346">Source</a><h4 class="code-header">pub fn <a href="#method.anti_join" class="fn">anti_join</a>&lt;O2&gt;(
    self,
    n: <a class="struct" href="struct.Stream.html" title="struct hydro_lang::stream::Stream">Stream</a>&lt;K, L, <a class="enum" href="../boundedness/enum.Bounded.html" title="enum hydro_lang::boundedness::Bounded">Bounded</a>, O2&gt;,
) -&gt; <a class="struct" href="struct.Stream.html" title="struct hydro_lang::stream::Stream">Stream</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">(K, V1)</a>, L, B, Order&gt;<div class="where">where
    K: <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html" title="trait core::hash::Hash">Hash</a>,</div></h4></section></summary><div class="docblock"><p>Given a stream of pairs <code>(K, V1)</code> and a bounded stream of keys <code>K</code>,
computes the anti-join of the items in the input – i.e. returns
unique items in the first input that do not have a matching key
in the second input.</p>
<h5 id="example-28"><a class="doc-anchor" href="#example-28">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>tick = process.tick();
<span class="kw">let </span>stream = <span class="kw">unsafe </span>{
   process
   .source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[ (<span class="number">1</span>, <span class="string">'a'</span>), (<span class="number">2</span>, <span class="string">'b'</span>), (<span class="number">3</span>, <span class="string">'c'</span>), (<span class="number">4</span>, <span class="string">'d'</span>) ]))
   .tick_batch(<span class="kw-2">&amp;</span>tick)
};
<span class="kw">let </span>batch = <span class="kw">unsafe </span>{
    process
        .source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>]))
        .tick_batch(<span class="kw-2">&amp;</span>tick)
};
stream.anti_join(batch).all_ticks()</code></pre></div>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Stream%3C(K,+V),+Tick%3CL%3E,+Bounded%3E" class="impl"><a class="src rightside" href="../../src/hydro_lang/stream.rs.html#1349-1435">Source</a><a href="#impl-Stream%3C(K,+V),+Tick%3CL%3E,+Bounded%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a, K: <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html" title="trait core::hash::Hash">Hash</a>, V, L: <a class="trait" href="../location/trait.Location.html" title="trait hydro_lang::location::Location">Location</a>&lt;'a&gt;&gt; <a class="struct" href="struct.Stream.html" title="struct hydro_lang::stream::Stream">Stream</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">(K, V)</a>, <a class="struct" href="../location/tick/struct.Tick.html" title="struct hydro_lang::location::tick::Tick">Tick</a>&lt;L&gt;, <a class="enum" href="../boundedness/enum.Bounded.html" title="enum hydro_lang::boundedness::Bounded">Bounded</a>&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fold_keyed" class="method"><a class="src rightside" href="../../src/hydro_lang/stream.rs.html#1377-1394">Source</a><h4 class="code-header">pub fn <a href="#method.fold_keyed" class="fn">fold_keyed</a>&lt;A, I: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>() -&gt; A + 'a, F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut A</a>, V) + 'a&gt;(
    self,
    init: impl IntoQuotedMut&lt;'a, I, <a class="struct" href="../location/tick/struct.Tick.html" title="struct hydro_lang::location::tick::Tick">Tick</a>&lt;L&gt;&gt;,
    comb: impl IntoQuotedMut&lt;'a, F, <a class="struct" href="../location/tick/struct.Tick.html" title="struct hydro_lang::location::tick::Tick">Tick</a>&lt;L&gt;&gt;,
) -&gt; <a class="struct" href="struct.Stream.html" title="struct hydro_lang::stream::Stream">Stream</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">(K, A)</a>, <a class="struct" href="../location/tick/struct.Tick.html" title="struct hydro_lang::location::tick::Tick">Tick</a>&lt;L&gt;, <a class="enum" href="../boundedness/enum.Bounded.html" title="enum hydro_lang::boundedness::Bounded">Bounded</a>&gt;</h4></section></summary><div class="docblock"><p>A special case of <a href="struct.Stream.html#method.fold" title="method hydro_lang::stream::Stream::fold"><code>Stream::fold</code></a>, in the spirit of SQL’s GROUP BY and aggregation constructs. The input
tuples are partitioned into groups by the first element (“keys”), and for each group the values
in the second element are accumulated via the <code>comb</code> closure.</p>
<p>The input stream must have a <a href="struct.TotalOrder.html" title="struct hydro_lang::stream::TotalOrder"><code>TotalOrder</code></a> guarantee, which means that the <code>comb</code> closure is allowed
to depend on the order of elements in the stream.</p>
<p>If the input and output value types are the same and do not require initialization then use
<a href="struct.Stream.html#method.reduce_keyed" title="method hydro_lang::stream::Stream::reduce_keyed"><code>Stream::reduce_keyed</code></a>.</p>
<h5 id="example-29"><a class="doc-anchor" href="#example-29">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>tick = process.tick();
<span class="kw">let </span>numbers = process.source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">2</span>, <span class="number">3</span>), (<span class="number">1</span>, <span class="number">3</span>), (<span class="number">2</span>, <span class="number">4</span>)]));
<span class="kw">let </span>batch = <span class="kw">unsafe </span>{ numbers.tick_batch(<span class="kw-2">&amp;</span>tick) };
batch
    .fold_keyed(<span class="macro">q!</span>(|| <span class="number">0</span>), <span class="macro">q!</span>(|acc, x| <span class="kw-2">*</span>acc += x))
    .all_ticks()
<span class="comment">// (1, 5), (2, 7)</span></code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.reduce_keyed" class="method"><a class="src rightside" href="../../src/hydro_lang/stream.rs.html#1420-1434">Source</a><h4 class="code-header">pub fn <a href="#method.reduce_keyed" class="fn">reduce_keyed</a>&lt;F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut V</a>, V) + 'a&gt;(
    self,
    comb: impl IntoQuotedMut&lt;'a, F, <a class="struct" href="../location/tick/struct.Tick.html" title="struct hydro_lang::location::tick::Tick">Tick</a>&lt;L&gt;&gt;,
) -&gt; <a class="struct" href="struct.Stream.html" title="struct hydro_lang::stream::Stream">Stream</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">(K, V)</a>, <a class="struct" href="../location/tick/struct.Tick.html" title="struct hydro_lang::location::tick::Tick">Tick</a>&lt;L&gt;, <a class="enum" href="../boundedness/enum.Bounded.html" title="enum hydro_lang::boundedness::Bounded">Bounded</a>&gt;</h4></section></summary><div class="docblock"><p>A special case of <a href="struct.Stream.html#method.reduce" title="method hydro_lang::stream::Stream::reduce"><code>Stream::reduce</code></a>, in the spirit of SQL’s GROUP BY and aggregation constructs. The input
tuples are partitioned into groups by the first element (“keys”), and for each group the values
in the second element are accumulated via the <code>comb</code> closure.</p>
<p>The input stream must have a <a href="struct.TotalOrder.html" title="struct hydro_lang::stream::TotalOrder"><code>TotalOrder</code></a> guarantee, which means that the <code>comb</code> closure is allowed
to depend on the order of elements in the stream.</p>
<p>If you need the accumulated value to have a different type than the input, use <a href="struct.Stream.html#method.fold_keyed" title="method hydro_lang::stream::Stream::fold_keyed"><code>Stream::fold_keyed</code></a>.</p>
<h5 id="example-30"><a class="doc-anchor" href="#example-30">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>tick = process.tick();
<span class="kw">let </span>numbers = process.source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">2</span>, <span class="number">3</span>), (<span class="number">1</span>, <span class="number">3</span>), (<span class="number">2</span>, <span class="number">4</span>)]));
<span class="kw">let </span>batch = <span class="kw">unsafe </span>{ numbers.tick_batch(<span class="kw-2">&amp;</span>tick) };
batch.reduce_keyed(<span class="macro">q!</span>(|acc, x| <span class="kw-2">*</span>acc += x)).all_ticks()
<span class="comment">// (1, 5), (2, 7)</span></code></pre></div>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Stream%3C(K,+V),+Tick%3CL%3E,+Bounded,+Order%3E" class="impl"><a class="src rightside" href="../../src/hydro_lang/stream.rs.html#1437-1544">Source</a><a href="#impl-Stream%3C(K,+V),+Tick%3CL%3E,+Bounded,+Order%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a, K: <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html" title="trait core::hash::Hash">Hash</a>, V, L: <a class="trait" href="../location/trait.Location.html" title="trait hydro_lang::location::Location">Location</a>&lt;'a&gt;, Order&gt; <a class="struct" href="struct.Stream.html" title="struct hydro_lang::stream::Stream">Stream</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">(K, V)</a>, <a class="struct" href="../location/tick/struct.Tick.html" title="struct hydro_lang::location::tick::Tick">Tick</a>&lt;L&gt;, <a class="enum" href="../boundedness/enum.Bounded.html" title="enum hydro_lang::boundedness::Bounded">Bounded</a>, Order&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fold_keyed_commutative" class="method"><a class="src rightside" href="../../src/hydro_lang/stream.rs.html#1464-1481">Source</a><h4 class="code-header">pub fn <a href="#method.fold_keyed_commutative" class="fn">fold_keyed_commutative</a>&lt;A, I: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>() -&gt; A + 'a, F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut A</a>, V) + 'a&gt;(
    self,
    init: impl IntoQuotedMut&lt;'a, I, <a class="struct" href="../location/tick/struct.Tick.html" title="struct hydro_lang::location::tick::Tick">Tick</a>&lt;L&gt;&gt;,
    comb: impl IntoQuotedMut&lt;'a, F, <a class="struct" href="../location/tick/struct.Tick.html" title="struct hydro_lang::location::tick::Tick">Tick</a>&lt;L&gt;&gt;,
) -&gt; <a class="struct" href="struct.Stream.html" title="struct hydro_lang::stream::Stream">Stream</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">(K, A)</a>, <a class="struct" href="../location/tick/struct.Tick.html" title="struct hydro_lang::location::tick::Tick">Tick</a>&lt;L&gt;, <a class="enum" href="../boundedness/enum.Bounded.html" title="enum hydro_lang::boundedness::Bounded">Bounded</a>, Order&gt;</h4></section></summary><div class="docblock"><p>A special case of <a href="struct.Stream.html#method.fold_commutative" title="method hydro_lang::stream::Stream::fold_commutative"><code>Stream::fold_commutative</code></a>, in the spirit of SQL’s GROUP BY and aggregation constructs. The input
tuples are partitioned into groups by the first element (“keys”), and for each group the values
in the second element are accumulated via the <code>comb</code> closure.</p>
<p>The <code>comb</code> closure must be <strong>commutative</strong>, as the order of input items is not guaranteed.</p>
<p>If the input and output value types are the same and do not require initialization then use
<a href="struct.Stream.html#method.reduce_keyed_commutative" title="method hydro_lang::stream::Stream::reduce_keyed_commutative"><code>Stream::reduce_keyed_commutative</code></a>.</p>
<h5 id="example-31"><a class="doc-anchor" href="#example-31">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>tick = process.tick();
<span class="kw">let </span>numbers = process.source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">2</span>, <span class="number">3</span>), (<span class="number">1</span>, <span class="number">3</span>), (<span class="number">2</span>, <span class="number">4</span>)]));
<span class="kw">let </span>batch = <span class="kw">unsafe </span>{ numbers.tick_batch(<span class="kw-2">&amp;</span>tick) };
batch
    .fold_keyed_commutative(<span class="macro">q!</span>(|| <span class="number">0</span>), <span class="macro">q!</span>(|acc, x| <span class="kw-2">*</span>acc += x))
    .all_ticks()
<span class="comment">// (1, 5), (2, 7)</span></code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.keys" class="method"><a class="src rightside" href="../../src/hydro_lang/stream.rs.html#1499-1502">Source</a><h4 class="code-header">pub fn <a href="#method.keys" class="fn">keys</a>(self) -&gt; <a class="struct" href="struct.Stream.html" title="struct hydro_lang::stream::Stream">Stream</a>&lt;K, <a class="struct" href="../location/tick/struct.Tick.html" title="struct hydro_lang::location::tick::Tick">Tick</a>&lt;L&gt;, <a class="enum" href="../boundedness/enum.Bounded.html" title="enum hydro_lang::boundedness::Bounded">Bounded</a>, Order&gt;</h4></section></summary><div class="docblock"><p>Given a stream of pairs <code>(K, V)</code>, produces a new stream of unique keys <code>K</code>.</p>
<h5 id="example-32"><a class="doc-anchor" href="#example-32">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>tick = process.tick();
<span class="kw">let </span>numbers = process.source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">2</span>, <span class="number">3</span>), (<span class="number">1</span>, <span class="number">3</span>), (<span class="number">2</span>, <span class="number">4</span>)]));
<span class="kw">let </span>batch = <span class="kw">unsafe </span>{ numbers.tick_batch(<span class="kw-2">&amp;</span>tick) };
batch.keys().all_ticks()
<span class="comment">// 1, 2</span></code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.reduce_keyed_commutative" class="method"><a class="src rightside" href="../../src/hydro_lang/stream.rs.html#1529-1543">Source</a><h4 class="code-header">pub fn <a href="#method.reduce_keyed_commutative" class="fn">reduce_keyed_commutative</a>&lt;F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut V</a>, V) + 'a&gt;(
    self,
    comb: impl IntoQuotedMut&lt;'a, F, <a class="struct" href="../location/tick/struct.Tick.html" title="struct hydro_lang::location::tick::Tick">Tick</a>&lt;L&gt;&gt;,
) -&gt; <a class="struct" href="struct.Stream.html" title="struct hydro_lang::stream::Stream">Stream</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">(K, V)</a>, <a class="struct" href="../location/tick/struct.Tick.html" title="struct hydro_lang::location::tick::Tick">Tick</a>&lt;L&gt;, <a class="enum" href="../boundedness/enum.Bounded.html" title="enum hydro_lang::boundedness::Bounded">Bounded</a>, Order&gt;</h4></section></summary><div class="docblock"><p>A special case of <a href="struct.Stream.html#method.reduce_commutative" title="method hydro_lang::stream::Stream::reduce_commutative"><code>Stream::reduce_commutative</code></a>, in the spirit of SQL’s GROUP BY and aggregation constructs. The input
tuples are partitioned into groups by the first element (“keys”), and for each group the values
in the second element are accumulated via the <code>comb</code> closure.</p>
<p>The <code>comb</code> closure must be <strong>commutative</strong>, as the order of input items is not guaranteed.</p>
<p>If you need the accumulated value to have a different type than the input, use <a href="struct.Stream.html#method.fold_keyed_commutative" title="method hydro_lang::stream::Stream::fold_keyed_commutative"><code>Stream::fold_keyed_commutative</code></a>.</p>
<h5 id="example-33"><a class="doc-anchor" href="#example-33">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>tick = process.tick();
<span class="kw">let </span>numbers = process.source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">2</span>, <span class="number">3</span>), (<span class="number">1</span>, <span class="number">3</span>), (<span class="number">2</span>, <span class="number">4</span>)]));
<span class="kw">let </span>batch = <span class="kw">unsafe </span>{ numbers.tick_batch(<span class="kw-2">&amp;</span>tick) };
batch
    .reduce_keyed_commutative(<span class="macro">q!</span>(|acc, x| <span class="kw-2">*</span>acc += x))
    .all_ticks()
<span class="comment">// (1, 5), (2, 7)</span></code></pre></div>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Stream%3CT,+Atomic%3CL%3E,+B,+Order%3E" class="impl"><a class="src rightside" href="../../src/hydro_lang/stream.rs.html#1546-1570">Source</a><a href="#impl-Stream%3CT,+Atomic%3CL%3E,+B,+Order%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a, T, L: <a class="trait" href="../location/trait.Location.html" title="trait hydro_lang::location::Location">Location</a>&lt;'a&gt; + <a class="trait" href="../location/tick/trait.NoTick.html" title="trait hydro_lang::location::tick::NoTick">NoTick</a>, B, Order&gt; <a class="struct" href="struct.Stream.html" title="struct hydro_lang::stream::Stream">Stream</a>&lt;T, <a class="struct" href="../location/tick/struct.Atomic.html" title="struct hydro_lang::location::tick::Atomic">Atomic</a>&lt;L&gt;, B, Order&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.tick_batch" class="method"><a class="src rightside" href="../../src/hydro_lang/stream.rs.html#1553-1561">Source</a><h4 class="code-header">pub unsafe fn <a href="#method.tick_batch" class="fn">tick_batch</a>(self) -&gt; <a class="struct" href="struct.Stream.html" title="struct hydro_lang::stream::Stream">Stream</a>&lt;T, <a class="struct" href="../location/tick/struct.Tick.html" title="struct hydro_lang::location::tick::Tick">Tick</a>&lt;L&gt;, <a class="enum" href="../boundedness/enum.Bounded.html" title="enum hydro_lang::boundedness::Bounded">Bounded</a>, Order&gt;</h4></section></summary><div class="docblock"><p>Returns a stream corresponding to the latest batch of elements being atomically
processed. These batches are guaranteed to be contiguous across ticks and preserve
the order of the input.</p>
<h5 id="safety-1"><a class="doc-anchor" href="#safety-1">§</a>Safety</h5>
<p>The batch boundaries are non-deterministic and may change across executions.</p>
</div></details><section id="method.end_atomic" class="method"><a class="src rightside" href="../../src/hydro_lang/stream.rs.html#1563-1565">Source</a><h4 class="code-header">pub fn <a href="#method.end_atomic" class="fn">end_atomic</a>(self) -&gt; <a class="struct" href="struct.Stream.html" title="struct hydro_lang::stream::Stream">Stream</a>&lt;T, L, B, Order&gt;</h4></section><section id="method.atomic_source" class="method"><a class="src rightside" href="../../src/hydro_lang/stream.rs.html#1567-1569">Source</a><h4 class="code-header">pub fn <a href="#method.atomic_source" class="fn">atomic_source</a>(&amp;self) -&gt; <a class="struct" href="../location/tick/struct.Tick.html" title="struct hydro_lang::location::tick::Tick">Tick</a>&lt;L&gt;</h4></section></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Stream%3CT,+L,+B,+Order%3E-2" class="impl"><a class="src rightside" href="../../src/hydro_lang/stream.rs.html#1572-1737">Source</a><a href="#impl-Stream%3CT,+L,+B,+Order%3E-2" class="anchor">§</a><h3 class="code-header">impl&lt;'a, T, L: <a class="trait" href="../location/trait.Location.html" title="trait hydro_lang::location::Location">Location</a>&lt;'a&gt; + <a class="trait" href="../location/tick/trait.NoTick.html" title="trait hydro_lang::location::tick::NoTick">NoTick</a> + <a class="trait" href="../location/tick/trait.NoAtomic.html" title="trait hydro_lang::location::tick::NoAtomic">NoAtomic</a>, B, Order&gt; <a class="struct" href="struct.Stream.html" title="struct hydro_lang::stream::Stream">Stream</a>&lt;T, L, B, Order&gt;</h3></section></summary><div class="impl-items"><section id="method.atomic" class="method"><a class="src rightside" href="../../src/hydro_lang/stream.rs.html#1573-1575">Source</a><h4 class="code-header">pub fn <a href="#method.atomic" class="fn">atomic</a>(self, tick: &amp;<a class="struct" href="../location/tick/struct.Tick.html" title="struct hydro_lang::location::tick::Tick">Tick</a>&lt;L&gt;) -&gt; <a class="struct" href="struct.Stream.html" title="struct hydro_lang::stream::Stream">Stream</a>&lt;T, <a class="struct" href="../location/tick/struct.Atomic.html" title="struct hydro_lang::location::tick::Atomic">Atomic</a>&lt;L&gt;, B, Order&gt;</h4></section><details class="toggle method-toggle" open><summary><section id="method.resolve_futures" class="method"><a class="src rightside" href="../../src/hydro_lang/stream.rs.html#1605-1616">Source</a><h4 class="code-header">pub fn <a href="#method.resolve_futures" class="fn">resolve_futures</a>&lt;T2&gt;(self) -&gt; <a class="struct" href="struct.Stream.html" title="struct hydro_lang::stream::Stream">Stream</a>&lt;T2, L, B, <a class="struct" href="struct.NoOrder.html" title="struct hydro_lang::stream::NoOrder">NoOrder</a>&gt;<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/future/future/trait.Future.html" title="trait core::future::future::Future">Future</a>&lt;Output = T2&gt;,</div></h4></section></summary><div class="docblock"><p>Consumes a stream of <code>Future&lt;T&gt;</code>, produces a new stream of the resulting <code>T</code> outputs.
Future outputs are produced as available, regardless of input arrival order.</p>
<h5 id="example-34"><a class="doc-anchor" href="#example-34">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>process.source_iter(<span class="macro">q!</span>([<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">8</span>]))
    .map(<span class="macro">q!</span>(|x| <span class="kw">async move </span>{
        tokio::time::sleep(tokio::time::Duration::from_millis(<span class="number">10</span>)).<span class="kw">await</span>;
        x
    }))
    .resolve_futures()
<span class="comment">// 1, 2, 3, 4, 5, 6, 7, 8, 9 (in any order)</span></code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.resolve_futures_ordered" class="method"><a class="src rightside" href="../../src/hydro_lang/stream.rs.html#1646-1657">Source</a><h4 class="code-header">pub fn <a href="#method.resolve_futures_ordered" class="fn">resolve_futures_ordered</a>&lt;T2&gt;(self) -&gt; <a class="struct" href="struct.Stream.html" title="struct hydro_lang::stream::Stream">Stream</a>&lt;T2, L, B, Order&gt;<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/future/future/trait.Future.html" title="trait core::future::future::Future">Future</a>&lt;Output = T2&gt;,</div></h4></section></summary><div class="docblock"><p>Consumes a stream of <code>Future&lt;T&gt;</code>, produces a new stream of the resulting <code>T</code> outputs.
Future outputs are produced in the same order as the input stream.</p>
<h5 id="example-35"><a class="doc-anchor" href="#example-35">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>process.source_iter(<span class="macro">q!</span>([<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">8</span>]))
    .map(<span class="macro">q!</span>(|x| <span class="kw">async move </span>{
        tokio::time::sleep(tokio::time::Duration::from_millis(<span class="number">10</span>)).<span class="kw">await</span>;
        x
    }))
    .resolve_futures_ordered()
<span class="comment">// 2, 3, 1, 9, 6, 5, 4, 7, 8</span></code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.tick_batch-1" class="method"><a class="src rightside" href="../../src/hydro_lang/stream.rs.html#1665-1667">Source</a><h4 class="code-header">pub unsafe fn <a href="#method.tick_batch-1" class="fn">tick_batch</a>(
    self,
    tick: &amp;<a class="struct" href="../location/tick/struct.Tick.html" title="struct hydro_lang::location::tick::Tick">Tick</a>&lt;L&gt;,
) -&gt; <a class="struct" href="struct.Stream.html" title="struct hydro_lang::stream::Stream">Stream</a>&lt;T, <a class="struct" href="../location/tick/struct.Tick.html" title="struct hydro_lang::location::tick::Tick">Tick</a>&lt;L&gt;, <a class="enum" href="../boundedness/enum.Bounded.html" title="enum hydro_lang::boundedness::Bounded">Bounded</a>, Order&gt;</h4></section></summary><div class="docblock"><p>Given a tick, returns a stream corresponding to a batch of elements segmented by
that tick. These batches are guaranteed to be contiguous across ticks and preserve
the order of the input.</p>
<h5 id="safety-2"><a class="doc-anchor" href="#safety-2">§</a>Safety</h5>
<p>The batch boundaries are non-deterministic and may change across executions.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.sample_every" class="method"><a class="src rightside" href="../../src/hydro_lang/stream.rs.html#1677-1693">Source</a><h4 class="code-header">pub unsafe fn <a href="#method.sample_every" class="fn">sample_every</a>(
    self,
    interval: impl QuotedWithContext&lt;'a, <a class="struct" href="https://doc.rust-lang.org/nightly/core/time/struct.Duration.html" title="struct core::time::Duration">Duration</a>, L&gt; + <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Copy.html" title="trait core::marker::Copy">Copy</a> + 'a,
) -&gt; <a class="struct" href="struct.Stream.html" title="struct hydro_lang::stream::Stream">Stream</a>&lt;T, L, <a class="enum" href="../boundedness/enum.Unbounded.html" title="enum hydro_lang::boundedness::Unbounded">Unbounded</a>, Order&gt;</h4></section></summary><div class="docblock"><p>Given a time interval, returns a stream corresponding to samples taken from the
stream roughly at that interval. The output will have elements in the same order
as the input, but with arbitrary elements skipped between samples. There is also
no guarantee on the exact timing of the samples.</p>
<h5 id="safety-3"><a class="doc-anchor" href="#safety-3">§</a>Safety</h5>
<p>The output stream is non-deterministic in which elements are sampled, since this
is controlled by a clock.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.timeout" class="method"><a class="src rightside" href="../../src/hydro_lang/stream.rs.html#1704-1736">Source</a><h4 class="code-header">pub unsafe fn <a href="#method.timeout" class="fn">timeout</a>(
    self,
    duration: impl QuotedWithContext&lt;'a, <a class="struct" href="https://doc.rust-lang.org/nightly/core/time/struct.Duration.html" title="struct core::time::Duration">Duration</a>, <a class="struct" href="../location/tick/struct.Tick.html" title="struct hydro_lang::location::tick::Tick">Tick</a>&lt;L&gt;&gt; + <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Copy.html" title="trait core::marker::Copy">Copy</a> + 'a,
) -&gt; <a class="struct" href="../optional/struct.Optional.html" title="struct hydro_lang::optional::Optional">Optional</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>, L, <a class="enum" href="../boundedness/enum.Unbounded.html" title="enum hydro_lang::boundedness::Unbounded">Unbounded</a>&gt;<div class="where">where
    Order: <a class="trait" href="trait.MinOrder.html" title="trait hydro_lang::stream::MinOrder">MinOrder</a>&lt;<a class="struct" href="struct.NoOrder.html" title="struct hydro_lang::stream::NoOrder">NoOrder</a>, Min = <a class="struct" href="struct.NoOrder.html" title="struct hydro_lang::stream::NoOrder">NoOrder</a>&gt;,</div></h4></section></summary><div class="docblock"><p>Given a timeout duration, returns an <a href="../optional/struct.Optional.html" title="struct hydro_lang::optional::Optional"><code>Optional</code></a>  which will have a value if the
stream has not emitted a value since that duration.</p>
<h5 id="safety-4"><a class="doc-anchor" href="#safety-4">§</a>Safety</h5>
<p>Timeout relies on non-deterministic sampling of the stream, so depending on when
samples take place, timeouts may be non-deterministically generated or missed,
and the notification of the timeout may be delayed as well. There is also no
guarantee on how long the <a href="../optional/struct.Optional.html" title="struct hydro_lang::optional::Optional"><code>Optional</code></a> will have a value after the timeout is
detected based on when the next sample is taken.</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Stream%3CT,+L,+B,+Order%3E-3" class="impl"><a class="src rightside" href="../../src/hydro_lang/stream.rs.html#1739-1775">Source</a><a href="#impl-Stream%3CT,+L,+B,+Order%3E-3" class="anchor">§</a><h3 class="code-header">impl&lt;'a, T, L: <a class="trait" href="../location/trait.Location.html" title="trait hydro_lang::location::Location">Location</a>&lt;'a&gt; + <a class="trait" href="../location/tick/trait.NoTick.html" title="trait hydro_lang::location::tick::NoTick">NoTick</a>, B, Order&gt; <a class="struct" href="struct.Stream.html" title="struct hydro_lang::stream::Stream">Stream</a>&lt;T, L, B, Order&gt;</h3></section></summary><div class="impl-items"><section id="method.for_each" class="method"><a class="src rightside" href="../../src/hydro_lang/stream.rs.html#1740-1757">Source</a><h4 class="code-header">pub fn <a href="#method.for_each" class="fn">for_each</a>&lt;F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(T) + 'a&gt;(self, f: impl IntoQuotedMut&lt;'a, F, L&gt;)</h4></section><section id="method.dest_sink" class="method"><a class="src rightside" href="../../src/hydro_lang/stream.rs.html#1759-1774">Source</a><h4 class="code-header">pub fn <a href="#method.dest_sink" class="fn">dest_sink</a>&lt;S: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> + Sink&lt;T&gt; + 'a&gt;(
    self,
    sink: impl QuotedWithContext&lt;'a, S, L&gt;,
)</h4></section></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Stream%3CT,+Tick%3CL%3E,+Bounded,+Order%3E" class="impl"><a class="src rightside" href="../../src/hydro_lang/stream.rs.html#1777-1832">Source</a><a href="#impl-Stream%3CT,+Tick%3CL%3E,+Bounded,+Order%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a, T, L: <a class="trait" href="../location/trait.Location.html" title="trait hydro_lang::location::Location">Location</a>&lt;'a&gt;, Order&gt; <a class="struct" href="struct.Stream.html" title="struct hydro_lang::stream::Stream">Stream</a>&lt;T, <a class="struct" href="../location/tick/struct.Tick.html" title="struct hydro_lang::location::tick::Tick">Tick</a>&lt;L&gt;, <a class="enum" href="../boundedness/enum.Bounded.html" title="enum hydro_lang::boundedness::Bounded">Bounded</a>, Order&gt;</h3></section></summary><div class="impl-items"><section id="method.all_ticks" class="method"><a class="src rightside" href="../../src/hydro_lang/stream.rs.html#1778-1786">Source</a><h4 class="code-header">pub fn <a href="#method.all_ticks" class="fn">all_ticks</a>(self) -&gt; <a class="struct" href="struct.Stream.html" title="struct hydro_lang::stream::Stream">Stream</a>&lt;T, L, <a class="enum" href="../boundedness/enum.Unbounded.html" title="enum hydro_lang::boundedness::Unbounded">Unbounded</a>, Order&gt;</h4></section><section id="method.all_ticks_atomic" class="method"><a class="src rightside" href="../../src/hydro_lang/stream.rs.html#1788-1798">Source</a><h4 class="code-header">pub fn <a href="#method.all_ticks_atomic" class="fn">all_ticks_atomic</a>(self) -&gt; <a class="struct" href="struct.Stream.html" title="struct hydro_lang::stream::Stream">Stream</a>&lt;T, <a class="struct" href="../location/tick/struct.Atomic.html" title="struct hydro_lang::location::tick::Atomic">Atomic</a>&lt;L&gt;, <a class="enum" href="../boundedness/enum.Unbounded.html" title="enum hydro_lang::boundedness::Unbounded">Unbounded</a>, Order&gt;</h4></section><section id="method.persist" class="method"><a class="src rightside" href="../../src/hydro_lang/stream.rs.html#1800-1811">Source</a><h4 class="code-header">pub fn <a href="#method.persist" class="fn">persist</a>(self) -&gt; <a class="struct" href="struct.Stream.html" title="struct hydro_lang::stream::Stream">Stream</a>&lt;T, <a class="struct" href="../location/tick/struct.Tick.html" title="struct hydro_lang::location::tick::Tick">Tick</a>&lt;L&gt;, <a class="enum" href="../boundedness/enum.Bounded.html" title="enum hydro_lang::boundedness::Bounded">Bounded</a>, Order&gt;<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</div></h4></section><section id="method.defer_tick" class="method"><a class="src rightside" href="../../src/hydro_lang/stream.rs.html#1813-1821">Source</a><h4 class="code-header">pub fn <a href="#method.defer_tick" class="fn">defer_tick</a>(self) -&gt; <a class="struct" href="struct.Stream.html" title="struct hydro_lang::stream::Stream">Stream</a>&lt;T, <a class="struct" href="../location/tick/struct.Tick.html" title="struct hydro_lang::location::tick::Tick">Tick</a>&lt;L&gt;, <a class="enum" href="../boundedness/enum.Bounded.html" title="enum hydro_lang::boundedness::Bounded">Bounded</a>, Order&gt;</h4></section><section id="method.delta" class="method"><a class="src rightside" href="../../src/hydro_lang/stream.rs.html#1823-1831">Source</a><h4 class="code-header">pub fn <a href="#method.delta" class="fn">delta</a>(self) -&gt; <a class="struct" href="struct.Stream.html" title="struct hydro_lang::stream::Stream">Stream</a>&lt;T, <a class="struct" href="../location/tick/struct.Tick.html" title="struct hydro_lang::location::tick::Tick">Tick</a>&lt;L&gt;, <a class="enum" href="../boundedness/enum.Bounded.html" title="enum hydro_lang::boundedness::Bounded">Bounded</a>, Order&gt;</h4></section></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Stream%3CT,+L,+B,+Order%3E-4" class="impl"><a class="src rightside" href="../../src/hydro_lang/stream.rs.html#1883-2116">Source</a><a href="#impl-Stream%3CT,+L,+B,+Order%3E-4" class="anchor">§</a><h3 class="code-header">impl&lt;'a, T, L: <a class="trait" href="../location/trait.Location.html" title="trait hydro_lang::location::Location">Location</a>&lt;'a&gt; + <a class="trait" href="../location/tick/trait.NoTick.html" title="trait hydro_lang::location::tick::NoTick">NoTick</a>, B, Order&gt; <a class="struct" href="struct.Stream.html" title="struct hydro_lang::stream::Stream">Stream</a>&lt;T, L, B, Order&gt;</h3></section></summary><div class="impl-items"><section id="method.send_bincode" class="method"><a class="src rightside" href="../../src/hydro_lang/stream.rs.html#1884-1910">Source</a><h4 class="code-header">pub fn <a href="#method.send_bincode" class="fn">send_bincode</a>&lt;L2: <a class="trait" href="../location/trait.Location.html" title="trait hydro_lang::location::Location">Location</a>&lt;'a&gt;, CoreType&gt;(
    self,
    other: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;L2</a>,
) -&gt; <a class="struct" href="struct.Stream.html" title="struct hydro_lang::stream::Stream">Stream</a>&lt;&lt;L::<a class="associatedtype" href="../location/trait.Location.html#associatedtype.Root" title="type hydro_lang::location::Location::Root">Root</a> as <a class="trait" href="../location/can_send/trait.CanSend.html" title="trait hydro_lang::location::can_send::CanSend">CanSend</a>&lt;'a, L2&gt;&gt;::<a class="associatedtype" href="../location/can_send/trait.CanSend.html#associatedtype.Out" title="type hydro_lang::location::can_send::CanSend::Out">Out</a>&lt;CoreType&gt;, L2, <a class="enum" href="../boundedness/enum.Unbounded.html" title="enum hydro_lang::boundedness::Unbounded">Unbounded</a>, Order::<a class="associatedtype" href="trait.MinOrder.html#associatedtype.Min" title="type hydro_lang::stream::MinOrder::Min">Min</a>&gt;<div class="where">where
    L::<a class="associatedtype" href="../location/trait.Location.html#associatedtype.Root" title="type hydro_lang::location::Location::Root">Root</a>: <a class="trait" href="../location/can_send/trait.CanSend.html" title="trait hydro_lang::location::can_send::CanSend">CanSend</a>&lt;'a, L2, In&lt;CoreType&gt; = T&gt;,
    CoreType: <a class="trait" href="https://docs.rs/serde/1.0.210/serde/ser/trait.Serialize.html" title="trait serde::ser::Serialize">Serialize</a> + <a class="trait" href="https://docs.rs/serde/1.0.210/serde/de/trait.DeserializeOwned.html" title="trait serde::de::DeserializeOwned">DeserializeOwned</a>,
    Order: <a class="trait" href="trait.MinOrder.html" title="trait hydro_lang::stream::MinOrder">MinOrder</a>&lt;&lt;L::<a class="associatedtype" href="../location/trait.Location.html#associatedtype.Root" title="type hydro_lang::location::Location::Root">Root</a> as <a class="trait" href="../location/can_send/trait.CanSend.html" title="trait hydro_lang::location::can_send::CanSend">CanSend</a>&lt;'a, L2&gt;&gt;::<a class="associatedtype" href="../location/can_send/trait.CanSend.html#associatedtype.OutStrongestOrder" title="type hydro_lang::location::can_send::CanSend::OutStrongestOrder">OutStrongestOrder</a>&lt;Order&gt;&gt;,</div></h4></section><section id="method.send_bincode_external" class="method"><a class="src rightside" href="../../src/hydro_lang/stream.rs.html#1912-1954">Source</a><h4 class="code-header">pub fn <a href="#method.send_bincode_external" class="fn">send_bincode_external</a>&lt;L2: 'a, CoreType&gt;(
    self,
    other: &amp;<a class="struct" href="../location/external_process/struct.ExternalProcess.html" title="struct hydro_lang::location::external_process::ExternalProcess">ExternalProcess</a>&lt;'_, L2&gt;,
) -&gt; <a class="struct" href="../location/external_process/struct.ExternalBincodeStream.html" title="struct hydro_lang::location::external_process::ExternalBincodeStream">ExternalBincodeStream</a>&lt;L::<a class="associatedtype" href="../location/can_send/trait.CanSend.html#associatedtype.Out" title="type hydro_lang::location::can_send::CanSend::Out">Out</a>&lt;CoreType&gt;&gt;<div class="where">where
    L: <a class="trait" href="../location/can_send/trait.CanSend.html" title="trait hydro_lang::location::can_send::CanSend">CanSend</a>&lt;'a, <a class="struct" href="../location/external_process/struct.ExternalProcess.html" title="struct hydro_lang::location::external_process::ExternalProcess">ExternalProcess</a>&lt;'a, L2&gt;, In&lt;CoreType&gt; = T, Out&lt;CoreType&gt; = CoreType&gt;,
    CoreType: <a class="trait" href="https://docs.rs/serde/1.0.210/serde/ser/trait.Serialize.html" title="trait serde::ser::Serialize">Serialize</a> + <a class="trait" href="https://docs.rs/serde/1.0.210/serde/de/trait.DeserializeOwned.html" title="trait serde::de::DeserializeOwned">DeserializeOwned</a>,</div></h4></section><section id="method.send_bytes" class="method"><a class="src rightside" href="../../src/hydro_lang/stream.rs.html#1956-1984">Source</a><h4 class="code-header">pub fn <a href="#method.send_bytes" class="fn">send_bytes</a>&lt;L2: <a class="trait" href="../location/trait.Location.html" title="trait hydro_lang::location::Location">Location</a>&lt;'a&gt;&gt;(
    self,
    other: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;L2</a>,
) -&gt; <a class="struct" href="struct.Stream.html" title="struct hydro_lang::stream::Stream">Stream</a>&lt;&lt;L::<a class="associatedtype" href="../location/trait.Location.html#associatedtype.Root" title="type hydro_lang::location::Location::Root">Root</a> as <a class="trait" href="../location/can_send/trait.CanSend.html" title="trait hydro_lang::location::can_send::CanSend">CanSend</a>&lt;'a, L2&gt;&gt;::<a class="associatedtype" href="../location/can_send/trait.CanSend.html#associatedtype.Out" title="type hydro_lang::location::can_send::CanSend::Out">Out</a>&lt;Bytes&gt;, L2, <a class="enum" href="../boundedness/enum.Unbounded.html" title="enum hydro_lang::boundedness::Unbounded">Unbounded</a>, Order::<a class="associatedtype" href="trait.MinOrder.html#associatedtype.Min" title="type hydro_lang::stream::MinOrder::Min">Min</a>&gt;<div class="where">where
    L::<a class="associatedtype" href="../location/trait.Location.html#associatedtype.Root" title="type hydro_lang::location::Location::Root">Root</a>: <a class="trait" href="../location/can_send/trait.CanSend.html" title="trait hydro_lang::location::can_send::CanSend">CanSend</a>&lt;'a, L2, In&lt;Bytes&gt; = T&gt;,
    Order: <a class="trait" href="trait.MinOrder.html" title="trait hydro_lang::stream::MinOrder">MinOrder</a>&lt;&lt;L::<a class="associatedtype" href="../location/trait.Location.html#associatedtype.Root" title="type hydro_lang::location::Location::Root">Root</a> as <a class="trait" href="../location/can_send/trait.CanSend.html" title="trait hydro_lang::location::can_send::CanSend">CanSend</a>&lt;'a, L2&gt;&gt;::<a class="associatedtype" href="../location/can_send/trait.CanSend.html#associatedtype.OutStrongestOrder" title="type hydro_lang::location::can_send::CanSend::OutStrongestOrder">OutStrongestOrder</a>&lt;Order&gt;&gt;,</div></h4></section><section id="method.send_bytes_external" class="method"><a class="src rightside" href="../../src/hydro_lang/stream.rs.html#1986-2019">Source</a><h4 class="code-header">pub fn <a href="#method.send_bytes_external" class="fn">send_bytes_external</a>&lt;L2: 'a&gt;(
    self,
    other: &amp;<a class="struct" href="../location/external_process/struct.ExternalProcess.html" title="struct hydro_lang::location::external_process::ExternalProcess">ExternalProcess</a>&lt;'_, L2&gt;,
) -&gt; <a class="struct" href="../location/external_process/struct.ExternalBytesPort.html" title="struct hydro_lang::location::external_process::ExternalBytesPort">ExternalBytesPort</a><div class="where">where
    L::<a class="associatedtype" href="../location/trait.Location.html#associatedtype.Root" title="type hydro_lang::location::Location::Root">Root</a>: <a class="trait" href="../location/can_send/trait.CanSend.html" title="trait hydro_lang::location::can_send::CanSend">CanSend</a>&lt;'a, <a class="struct" href="../location/external_process/struct.ExternalProcess.html" title="struct hydro_lang::location::external_process::ExternalProcess">ExternalProcess</a>&lt;'a, L2&gt;, In&lt;Bytes&gt; = T, Out&lt;Bytes&gt; = Bytes&gt;,</div></h4></section><section id="method.send_bincode_anonymous" class="method"><a class="src rightside" href="../../src/hydro_lang/stream.rs.html#2021-2031">Source</a><h4 class="code-header">pub fn <a href="#method.send_bincode_anonymous" class="fn">send_bincode_anonymous</a>&lt;L2: <a class="trait" href="../location/trait.Location.html" title="trait hydro_lang::location::Location">Location</a>&lt;'a&gt;, Tag, CoreType&gt;(
    self,
    other: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;L2</a>,
) -&gt; <a class="struct" href="struct.Stream.html" title="struct hydro_lang::stream::Stream">Stream</a>&lt;CoreType, L2, <a class="enum" href="../boundedness/enum.Unbounded.html" title="enum hydro_lang::boundedness::Unbounded">Unbounded</a>, Order::<a class="associatedtype" href="trait.MinOrder.html#associatedtype.Min" title="type hydro_lang::stream::MinOrder::Min">Min</a>&gt;<div class="where">where
    L::<a class="associatedtype" href="../location/trait.Location.html#associatedtype.Root" title="type hydro_lang::location::Location::Root">Root</a>: <a class="trait" href="../location/can_send/trait.CanSend.html" title="trait hydro_lang::location::can_send::CanSend">CanSend</a>&lt;'a, L2, In&lt;CoreType&gt; = T, Out&lt;CoreType&gt; = <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">(Tag, CoreType)</a>&gt;,
    CoreType: <a class="trait" href="https://docs.rs/serde/1.0.210/serde/ser/trait.Serialize.html" title="trait serde::ser::Serialize">Serialize</a> + <a class="trait" href="https://docs.rs/serde/1.0.210/serde/de/trait.DeserializeOwned.html" title="trait serde::de::DeserializeOwned">DeserializeOwned</a>,
    Order: <a class="trait" href="trait.MinOrder.html" title="trait hydro_lang::stream::MinOrder">MinOrder</a>&lt;&lt;L::<a class="associatedtype" href="../location/trait.Location.html#associatedtype.Root" title="type hydro_lang::location::Location::Root">Root</a> as <a class="trait" href="../location/can_send/trait.CanSend.html" title="trait hydro_lang::location::can_send::CanSend">CanSend</a>&lt;'a, L2&gt;&gt;::<a class="associatedtype" href="../location/can_send/trait.CanSend.html#associatedtype.OutStrongestOrder" title="type hydro_lang::location::can_send::CanSend::OutStrongestOrder">OutStrongestOrder</a>&lt;Order&gt;&gt;,</div></h4></section><section id="method.send_bytes_anonymous" class="method"><a class="src rightside" href="../../src/hydro_lang/stream.rs.html#2033-2042">Source</a><h4 class="code-header">pub fn <a href="#method.send_bytes_anonymous" class="fn">send_bytes_anonymous</a>&lt;L2: <a class="trait" href="../location/trait.Location.html" title="trait hydro_lang::location::Location">Location</a>&lt;'a&gt;, Tag&gt;(
    self,
    other: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;L2</a>,
) -&gt; <a class="struct" href="struct.Stream.html" title="struct hydro_lang::stream::Stream">Stream</a>&lt;Bytes, L2, <a class="enum" href="../boundedness/enum.Unbounded.html" title="enum hydro_lang::boundedness::Unbounded">Unbounded</a>, Order::<a class="associatedtype" href="trait.MinOrder.html#associatedtype.Min" title="type hydro_lang::stream::MinOrder::Min">Min</a>&gt;<div class="where">where
    L::<a class="associatedtype" href="../location/trait.Location.html#associatedtype.Root" title="type hydro_lang::location::Location::Root">Root</a>: <a class="trait" href="../location/can_send/trait.CanSend.html" title="trait hydro_lang::location::can_send::CanSend">CanSend</a>&lt;'a, L2, In&lt;Bytes&gt; = T, Out&lt;Bytes&gt; = (Tag, Bytes)&gt;,
    Order: <a class="trait" href="trait.MinOrder.html" title="trait hydro_lang::stream::MinOrder">MinOrder</a>&lt;&lt;L::<a class="associatedtype" href="../location/trait.Location.html#associatedtype.Root" title="type hydro_lang::location::Location::Root">Root</a> as <a class="trait" href="../location/can_send/trait.CanSend.html" title="trait hydro_lang::location::can_send::CanSend">CanSend</a>&lt;'a, L2&gt;&gt;::<a class="associatedtype" href="../location/can_send/trait.CanSend.html#associatedtype.OutStrongestOrder" title="type hydro_lang::location::can_send::CanSend::OutStrongestOrder">OutStrongestOrder</a>&lt;Order&gt;&gt;,</div></h4></section><section id="method.broadcast_bincode" class="method"><a class="src rightside" href="../../src/hydro_lang/stream.rs.html#2045-2066">Source</a><h4 class="code-header">pub fn <a href="#method.broadcast_bincode" class="fn">broadcast_bincode</a>&lt;C2: 'a&gt;(
    self,
    other: &amp;<a class="struct" href="../location/cluster/struct.Cluster.html" title="struct hydro_lang::location::cluster::Cluster">Cluster</a>&lt;'a, C2&gt;,
) -&gt; <a class="struct" href="struct.Stream.html" title="struct hydro_lang::stream::Stream">Stream</a>&lt;&lt;L::<a class="associatedtype" href="../location/trait.Location.html#associatedtype.Root" title="type hydro_lang::location::Location::Root">Root</a> as <a class="trait" href="../location/can_send/trait.CanSend.html" title="trait hydro_lang::location::can_send::CanSend">CanSend</a>&lt;'a, <a class="struct" href="../location/cluster/struct.Cluster.html" title="struct hydro_lang::location::cluster::Cluster">Cluster</a>&lt;'a, C2&gt;&gt;&gt;::<a class="associatedtype" href="../location/can_send/trait.CanSend.html#associatedtype.Out" title="type hydro_lang::location::can_send::CanSend::Out">Out</a>&lt;T&gt;, <a class="struct" href="../location/cluster/struct.Cluster.html" title="struct hydro_lang::location::cluster::Cluster">Cluster</a>&lt;'a, C2&gt;, <a class="enum" href="../boundedness/enum.Unbounded.html" title="enum hydro_lang::boundedness::Unbounded">Unbounded</a>, Order::<a class="associatedtype" href="trait.MinOrder.html#associatedtype.Min" title="type hydro_lang::stream::MinOrder::Min">Min</a>&gt;<div class="where">where
    L::<a class="associatedtype" href="../location/trait.Location.html#associatedtype.Root" title="type hydro_lang::location::Location::Root">Root</a>: <a class="trait" href="../location/can_send/trait.CanSend.html" title="trait hydro_lang::location::can_send::CanSend">CanSend</a>&lt;'a, <a class="struct" href="../location/cluster/struct.Cluster.html" title="struct hydro_lang::location::cluster::Cluster">Cluster</a>&lt;'a, C2&gt;, In&lt;T&gt; = (<a class="struct" href="../location/cluster/cluster_id/struct.ClusterId.html" title="struct hydro_lang::location::cluster::cluster_id::ClusterId">ClusterId</a>&lt;C2&gt;, T)&gt;,
    T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> + <a class="trait" href="https://docs.rs/serde/1.0.210/serde/ser/trait.Serialize.html" title="trait serde::ser::Serialize">Serialize</a> + <a class="trait" href="https://docs.rs/serde/1.0.210/serde/de/trait.DeserializeOwned.html" title="trait serde::de::DeserializeOwned">DeserializeOwned</a>,
    Order: <a class="trait" href="trait.MinOrder.html" title="trait hydro_lang::stream::MinOrder">MinOrder</a>&lt;&lt;L::<a class="associatedtype" href="../location/trait.Location.html#associatedtype.Root" title="type hydro_lang::location::Location::Root">Root</a> as <a class="trait" href="../location/can_send/trait.CanSend.html" title="trait hydro_lang::location::can_send::CanSend">CanSend</a>&lt;'a, <a class="struct" href="../location/cluster/struct.Cluster.html" title="struct hydro_lang::location::cluster::Cluster">Cluster</a>&lt;'a, C2&gt;&gt;&gt;::<a class="associatedtype" href="../location/can_send/trait.CanSend.html#associatedtype.OutStrongestOrder" title="type hydro_lang::location::can_send::CanSend::OutStrongestOrder">OutStrongestOrder</a>&lt;Order&gt;&gt;,</div></h4></section><section id="method.broadcast_bincode_anonymous" class="method"><a class="src rightside" href="../../src/hydro_lang/stream.rs.html#2068-2078">Source</a><h4 class="code-header">pub fn <a href="#method.broadcast_bincode_anonymous" class="fn">broadcast_bincode_anonymous</a>&lt;C2: 'a, Tag&gt;(
    self,
    other: &amp;<a class="struct" href="../location/cluster/struct.Cluster.html" title="struct hydro_lang::location::cluster::Cluster">Cluster</a>&lt;'a, C2&gt;,
) -&gt; <a class="struct" href="struct.Stream.html" title="struct hydro_lang::stream::Stream">Stream</a>&lt;T, <a class="struct" href="../location/cluster/struct.Cluster.html" title="struct hydro_lang::location::cluster::Cluster">Cluster</a>&lt;'a, C2&gt;, <a class="enum" href="../boundedness/enum.Unbounded.html" title="enum hydro_lang::boundedness::Unbounded">Unbounded</a>, Order::<a class="associatedtype" href="trait.MinOrder.html#associatedtype.Min" title="type hydro_lang::stream::MinOrder::Min">Min</a>&gt;<div class="where">where
    L::<a class="associatedtype" href="../location/trait.Location.html#associatedtype.Root" title="type hydro_lang::location::Location::Root">Root</a>: <a class="trait" href="../location/can_send/trait.CanSend.html" title="trait hydro_lang::location::can_send::CanSend">CanSend</a>&lt;'a, <a class="struct" href="../location/cluster/struct.Cluster.html" title="struct hydro_lang::location::cluster::Cluster">Cluster</a>&lt;'a, C2&gt;, In&lt;T&gt; = (<a class="struct" href="../location/cluster/cluster_id/struct.ClusterId.html" title="struct hydro_lang::location::cluster::cluster_id::ClusterId">ClusterId</a>&lt;C2&gt;, T), Out&lt;T&gt; = <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">(Tag, T)</a>&gt; + 'a,
    T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> + <a class="trait" href="https://docs.rs/serde/1.0.210/serde/ser/trait.Serialize.html" title="trait serde::ser::Serialize">Serialize</a> + <a class="trait" href="https://docs.rs/serde/1.0.210/serde/de/trait.DeserializeOwned.html" title="trait serde::de::DeserializeOwned">DeserializeOwned</a>,
    Order: <a class="trait" href="trait.MinOrder.html" title="trait hydro_lang::stream::MinOrder">MinOrder</a>&lt;&lt;L::<a class="associatedtype" href="../location/trait.Location.html#associatedtype.Root" title="type hydro_lang::location::Location::Root">Root</a> as <a class="trait" href="../location/can_send/trait.CanSend.html" title="trait hydro_lang::location::can_send::CanSend">CanSend</a>&lt;'a, <a class="struct" href="../location/cluster/struct.Cluster.html" title="struct hydro_lang::location::cluster::Cluster">Cluster</a>&lt;'a, C2&gt;&gt;&gt;::<a class="associatedtype" href="../location/can_send/trait.CanSend.html#associatedtype.OutStrongestOrder" title="type hydro_lang::location::can_send::CanSend::OutStrongestOrder">OutStrongestOrder</a>&lt;Order&gt;&gt;,</div></h4></section><section id="method.broadcast_bytes" class="method"><a class="src rightside" href="../../src/hydro_lang/stream.rs.html#2081-2102">Source</a><h4 class="code-header">pub fn <a href="#method.broadcast_bytes" class="fn">broadcast_bytes</a>&lt;C2: 'a&gt;(
    self,
    other: &amp;<a class="struct" href="../location/cluster/struct.Cluster.html" title="struct hydro_lang::location::cluster::Cluster">Cluster</a>&lt;'a, C2&gt;,
) -&gt; <a class="struct" href="struct.Stream.html" title="struct hydro_lang::stream::Stream">Stream</a>&lt;&lt;L::<a class="associatedtype" href="../location/trait.Location.html#associatedtype.Root" title="type hydro_lang::location::Location::Root">Root</a> as <a class="trait" href="../location/can_send/trait.CanSend.html" title="trait hydro_lang::location::can_send::CanSend">CanSend</a>&lt;'a, <a class="struct" href="../location/cluster/struct.Cluster.html" title="struct hydro_lang::location::cluster::Cluster">Cluster</a>&lt;'a, C2&gt;&gt;&gt;::<a class="associatedtype" href="../location/can_send/trait.CanSend.html#associatedtype.Out" title="type hydro_lang::location::can_send::CanSend::Out">Out</a>&lt;Bytes&gt;, <a class="struct" href="../location/cluster/struct.Cluster.html" title="struct hydro_lang::location::cluster::Cluster">Cluster</a>&lt;'a, C2&gt;, <a class="enum" href="../boundedness/enum.Unbounded.html" title="enum hydro_lang::boundedness::Unbounded">Unbounded</a>, Order::<a class="associatedtype" href="trait.MinOrder.html#associatedtype.Min" title="type hydro_lang::stream::MinOrder::Min">Min</a>&gt;<div class="where">where
    L::<a class="associatedtype" href="../location/trait.Location.html#associatedtype.Root" title="type hydro_lang::location::Location::Root">Root</a>: <a class="trait" href="../location/can_send/trait.CanSend.html" title="trait hydro_lang::location::can_send::CanSend">CanSend</a>&lt;'a, <a class="struct" href="../location/cluster/struct.Cluster.html" title="struct hydro_lang::location::cluster::Cluster">Cluster</a>&lt;'a, C2&gt;, In&lt;Bytes&gt; = (<a class="struct" href="../location/cluster/cluster_id/struct.ClusterId.html" title="struct hydro_lang::location::cluster::cluster_id::ClusterId">ClusterId</a>&lt;C2&gt;, T)&gt; + 'a,
    T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,
    Order: <a class="trait" href="trait.MinOrder.html" title="trait hydro_lang::stream::MinOrder">MinOrder</a>&lt;&lt;L::<a class="associatedtype" href="../location/trait.Location.html#associatedtype.Root" title="type hydro_lang::location::Location::Root">Root</a> as <a class="trait" href="../location/can_send/trait.CanSend.html" title="trait hydro_lang::location::can_send::CanSend">CanSend</a>&lt;'a, <a class="struct" href="../location/cluster/struct.Cluster.html" title="struct hydro_lang::location::cluster::Cluster">Cluster</a>&lt;'a, C2&gt;&gt;&gt;::<a class="associatedtype" href="../location/can_send/trait.CanSend.html#associatedtype.OutStrongestOrder" title="type hydro_lang::location::can_send::CanSend::OutStrongestOrder">OutStrongestOrder</a>&lt;Order&gt;&gt;,</div></h4></section><section id="method.broadcast_bytes_anonymous" class="method"><a class="src rightside" href="../../src/hydro_lang/stream.rs.html#2104-2115">Source</a><h4 class="code-header">pub fn <a href="#method.broadcast_bytes_anonymous" class="fn">broadcast_bytes_anonymous</a>&lt;C2: 'a, Tag&gt;(
    self,
    other: &amp;<a class="struct" href="../location/cluster/struct.Cluster.html" title="struct hydro_lang::location::cluster::Cluster">Cluster</a>&lt;'a, C2&gt;,
) -&gt; <a class="struct" href="struct.Stream.html" title="struct hydro_lang::stream::Stream">Stream</a>&lt;Bytes, <a class="struct" href="../location/cluster/struct.Cluster.html" title="struct hydro_lang::location::cluster::Cluster">Cluster</a>&lt;'a, C2&gt;, <a class="enum" href="../boundedness/enum.Unbounded.html" title="enum hydro_lang::boundedness::Unbounded">Unbounded</a>, Order::<a class="associatedtype" href="trait.MinOrder.html#associatedtype.Min" title="type hydro_lang::stream::MinOrder::Min">Min</a>&gt;<div class="where">where
    L::<a class="associatedtype" href="../location/trait.Location.html#associatedtype.Root" title="type hydro_lang::location::Location::Root">Root</a>: <a class="trait" href="../location/can_send/trait.CanSend.html" title="trait hydro_lang::location::can_send::CanSend">CanSend</a>&lt;'a, <a class="struct" href="../location/cluster/struct.Cluster.html" title="struct hydro_lang::location::cluster::Cluster">Cluster</a>&lt;'a, C2&gt;, In&lt;Bytes&gt; = (<a class="struct" href="../location/cluster/cluster_id/struct.ClusterId.html" title="struct hydro_lang::location::cluster::cluster_id::ClusterId">ClusterId</a>&lt;C2&gt;, T), Out&lt;Bytes&gt; = (Tag, Bytes)&gt; + 'a,
    T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,
    Order: <a class="trait" href="trait.MinOrder.html" title="trait hydro_lang::stream::MinOrder">MinOrder</a>&lt;&lt;L::<a class="associatedtype" href="../location/trait.Location.html#associatedtype.Root" title="type hydro_lang::location::Location::Root">Root</a> as <a class="trait" href="../location/can_send/trait.CanSend.html" title="trait hydro_lang::location::can_send::CanSend">CanSend</a>&lt;'a, <a class="struct" href="../location/cluster/struct.Cluster.html" title="struct hydro_lang::location::cluster::Cluster">Cluster</a>&lt;'a, C2&gt;&gt;&gt;::<a class="associatedtype" href="../location/can_send/trait.CanSend.html#associatedtype.OutStrongestOrder" title="type hydro_lang::location::can_send::CanSend::OutStrongestOrder">OutStrongestOrder</a>&lt;Order&gt;&gt;,</div></h4></section></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Stream%3CT,+L,+B%3E-1" class="impl"><a class="src rightside" href="../../src/hydro_lang/stream.rs.html#2119-2208">Source</a><a href="#impl-Stream%3CT,+L,+B%3E-1" class="anchor">§</a><h3 class="code-header">impl&lt;'a, T, L: <a class="trait" href="../location/trait.Location.html" title="trait hydro_lang::location::Location">Location</a>&lt;'a&gt; + <a class="trait" href="../location/tick/trait.NoTick.html" title="trait hydro_lang::location::tick::NoTick">NoTick</a>, B&gt; <a class="struct" href="struct.Stream.html" title="struct hydro_lang::stream::Stream">Stream</a>&lt;T, L, B, <a class="struct" href="struct.TotalOrder.html" title="struct hydro_lang::stream::TotalOrder">TotalOrder</a>&gt;</h3></section></summary><div class="impl-items"><section id="method.round_robin_bincode" class="method"><a class="src rightside" href="../../src/hydro_lang/stream.rs.html#2120-2142">Source</a><h4 class="code-header">pub fn <a href="#method.round_robin_bincode" class="fn">round_robin_bincode</a>&lt;C2: 'a&gt;(
    self,
    other: &amp;<a class="struct" href="../location/cluster/struct.Cluster.html" title="struct hydro_lang::location::cluster::Cluster">Cluster</a>&lt;'a, C2&gt;,
) -&gt; <a class="struct" href="struct.Stream.html" title="struct hydro_lang::stream::Stream">Stream</a>&lt;&lt;L::<a class="associatedtype" href="../location/trait.Location.html#associatedtype.Root" title="type hydro_lang::location::Location::Root">Root</a> as <a class="trait" href="../location/can_send/trait.CanSend.html" title="trait hydro_lang::location::can_send::CanSend">CanSend</a>&lt;'a, <a class="struct" href="../location/cluster/struct.Cluster.html" title="struct hydro_lang::location::cluster::Cluster">Cluster</a>&lt;'a, C2&gt;&gt;&gt;::<a class="associatedtype" href="../location/can_send/trait.CanSend.html#associatedtype.Out" title="type hydro_lang::location::can_send::CanSend::Out">Out</a>&lt;T&gt;, <a class="struct" href="../location/cluster/struct.Cluster.html" title="struct hydro_lang::location::cluster::Cluster">Cluster</a>&lt;'a, C2&gt;, <a class="enum" href="../boundedness/enum.Unbounded.html" title="enum hydro_lang::boundedness::Unbounded">Unbounded</a>, &lt;<a class="struct" href="struct.TotalOrder.html" title="struct hydro_lang::stream::TotalOrder">TotalOrder</a> as <a class="trait" href="trait.MinOrder.html" title="trait hydro_lang::stream::MinOrder">MinOrder</a>&lt;&lt;L::<a class="associatedtype" href="../location/trait.Location.html#associatedtype.Root" title="type hydro_lang::location::Location::Root">Root</a> as <a class="trait" href="../location/can_send/trait.CanSend.html" title="trait hydro_lang::location::can_send::CanSend">CanSend</a>&lt;'a, <a class="struct" href="../location/cluster/struct.Cluster.html" title="struct hydro_lang::location::cluster::Cluster">Cluster</a>&lt;'a, C2&gt;&gt;&gt;::<a class="associatedtype" href="../location/can_send/trait.CanSend.html#associatedtype.OutStrongestOrder" title="type hydro_lang::location::can_send::CanSend::OutStrongestOrder">OutStrongestOrder</a>&lt;<a class="struct" href="struct.TotalOrder.html" title="struct hydro_lang::stream::TotalOrder">TotalOrder</a>&gt;&gt;&gt;::<a class="associatedtype" href="trait.MinOrder.html#associatedtype.Min" title="type hydro_lang::stream::MinOrder::Min">Min</a>&gt;<div class="where">where
    L::<a class="associatedtype" href="../location/trait.Location.html#associatedtype.Root" title="type hydro_lang::location::Location::Root">Root</a>: <a class="trait" href="../location/can_send/trait.CanSend.html" title="trait hydro_lang::location::can_send::CanSend">CanSend</a>&lt;'a, <a class="struct" href="../location/cluster/struct.Cluster.html" title="struct hydro_lang::location::cluster::Cluster">Cluster</a>&lt;'a, C2&gt;, In&lt;T&gt; = (<a class="struct" href="../location/cluster/cluster_id/struct.ClusterId.html" title="struct hydro_lang::location::cluster::cluster_id::ClusterId">ClusterId</a>&lt;C2&gt;, T)&gt;,
    T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> + <a class="trait" href="https://docs.rs/serde/1.0.210/serde/ser/trait.Serialize.html" title="trait serde::ser::Serialize">Serialize</a> + <a class="trait" href="https://docs.rs/serde/1.0.210/serde/de/trait.DeserializeOwned.html" title="trait serde::de::DeserializeOwned">DeserializeOwned</a>,
    <a class="struct" href="struct.TotalOrder.html" title="struct hydro_lang::stream::TotalOrder">TotalOrder</a>: <a class="trait" href="trait.MinOrder.html" title="trait hydro_lang::stream::MinOrder">MinOrder</a>&lt;&lt;L::<a class="associatedtype" href="../location/trait.Location.html#associatedtype.Root" title="type hydro_lang::location::Location::Root">Root</a> as <a class="trait" href="../location/can_send/trait.CanSend.html" title="trait hydro_lang::location::can_send::CanSend">CanSend</a>&lt;'a, <a class="struct" href="../location/cluster/struct.Cluster.html" title="struct hydro_lang::location::cluster::Cluster">Cluster</a>&lt;'a, C2&gt;&gt;&gt;::<a class="associatedtype" href="../location/can_send/trait.CanSend.html#associatedtype.OutStrongestOrder" title="type hydro_lang::location::can_send::CanSend::OutStrongestOrder">OutStrongestOrder</a>&lt;<a class="struct" href="struct.TotalOrder.html" title="struct hydro_lang::stream::TotalOrder">TotalOrder</a>&gt;&gt;,</div></h4></section><section id="method.round_robin_bincode_anonymous" class="method"><a class="src rightside" href="../../src/hydro_lang/stream.rs.html#2144-2162">Source</a><h4 class="code-header">pub fn <a href="#method.round_robin_bincode_anonymous" class="fn">round_robin_bincode_anonymous</a>&lt;C2: 'a, Tag&gt;(
    self,
    other: &amp;<a class="struct" href="../location/cluster/struct.Cluster.html" title="struct hydro_lang::location::cluster::Cluster">Cluster</a>&lt;'a, C2&gt;,
) -&gt; <a class="struct" href="struct.Stream.html" title="struct hydro_lang::stream::Stream">Stream</a>&lt;T, <a class="struct" href="../location/cluster/struct.Cluster.html" title="struct hydro_lang::location::cluster::Cluster">Cluster</a>&lt;'a, C2&gt;, <a class="enum" href="../boundedness/enum.Unbounded.html" title="enum hydro_lang::boundedness::Unbounded">Unbounded</a>, &lt;<a class="struct" href="struct.TotalOrder.html" title="struct hydro_lang::stream::TotalOrder">TotalOrder</a> as <a class="trait" href="trait.MinOrder.html" title="trait hydro_lang::stream::MinOrder">MinOrder</a>&lt;&lt;L::<a class="associatedtype" href="../location/trait.Location.html#associatedtype.Root" title="type hydro_lang::location::Location::Root">Root</a> as <a class="trait" href="../location/can_send/trait.CanSend.html" title="trait hydro_lang::location::can_send::CanSend">CanSend</a>&lt;'a, <a class="struct" href="../location/cluster/struct.Cluster.html" title="struct hydro_lang::location::cluster::Cluster">Cluster</a>&lt;'a, C2&gt;&gt;&gt;::<a class="associatedtype" href="../location/can_send/trait.CanSend.html#associatedtype.OutStrongestOrder" title="type hydro_lang::location::can_send::CanSend::OutStrongestOrder">OutStrongestOrder</a>&lt;<a class="struct" href="struct.TotalOrder.html" title="struct hydro_lang::stream::TotalOrder">TotalOrder</a>&gt;&gt;&gt;::<a class="associatedtype" href="trait.MinOrder.html#associatedtype.Min" title="type hydro_lang::stream::MinOrder::Min">Min</a>&gt;<div class="where">where
    L::<a class="associatedtype" href="../location/trait.Location.html#associatedtype.Root" title="type hydro_lang::location::Location::Root">Root</a>: <a class="trait" href="../location/can_send/trait.CanSend.html" title="trait hydro_lang::location::can_send::CanSend">CanSend</a>&lt;'a, <a class="struct" href="../location/cluster/struct.Cluster.html" title="struct hydro_lang::location::cluster::Cluster">Cluster</a>&lt;'a, C2&gt;, In&lt;T&gt; = (<a class="struct" href="../location/cluster/cluster_id/struct.ClusterId.html" title="struct hydro_lang::location::cluster::cluster_id::ClusterId">ClusterId</a>&lt;C2&gt;, T), Out&lt;T&gt; = <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">(Tag, T)</a>&gt; + 'a,
    T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> + <a class="trait" href="https://docs.rs/serde/1.0.210/serde/ser/trait.Serialize.html" title="trait serde::ser::Serialize">Serialize</a> + <a class="trait" href="https://docs.rs/serde/1.0.210/serde/de/trait.DeserializeOwned.html" title="trait serde::de::DeserializeOwned">DeserializeOwned</a>,
    <a class="struct" href="struct.TotalOrder.html" title="struct hydro_lang::stream::TotalOrder">TotalOrder</a>: <a class="trait" href="trait.MinOrder.html" title="trait hydro_lang::stream::MinOrder">MinOrder</a>&lt;&lt;L::<a class="associatedtype" href="../location/trait.Location.html#associatedtype.Root" title="type hydro_lang::location::Location::Root">Root</a> as <a class="trait" href="../location/can_send/trait.CanSend.html" title="trait hydro_lang::location::can_send::CanSend">CanSend</a>&lt;'a, <a class="struct" href="../location/cluster/struct.Cluster.html" title="struct hydro_lang::location::cluster::Cluster">Cluster</a>&lt;'a, C2&gt;&gt;&gt;::<a class="associatedtype" href="../location/can_send/trait.CanSend.html#associatedtype.OutStrongestOrder" title="type hydro_lang::location::can_send::CanSend::OutStrongestOrder">OutStrongestOrder</a>&lt;<a class="struct" href="struct.TotalOrder.html" title="struct hydro_lang::stream::TotalOrder">TotalOrder</a>&gt;&gt;,</div></h4></section><section id="method.round_robin_bytes" class="method"><a class="src rightside" href="../../src/hydro_lang/stream.rs.html#2164-2186">Source</a><h4 class="code-header">pub fn <a href="#method.round_robin_bytes" class="fn">round_robin_bytes</a>&lt;C2: 'a&gt;(
    self,
    other: &amp;<a class="struct" href="../location/cluster/struct.Cluster.html" title="struct hydro_lang::location::cluster::Cluster">Cluster</a>&lt;'a, C2&gt;,
) -&gt; <a class="struct" href="struct.Stream.html" title="struct hydro_lang::stream::Stream">Stream</a>&lt;&lt;L::<a class="associatedtype" href="../location/trait.Location.html#associatedtype.Root" title="type hydro_lang::location::Location::Root">Root</a> as <a class="trait" href="../location/can_send/trait.CanSend.html" title="trait hydro_lang::location::can_send::CanSend">CanSend</a>&lt;'a, <a class="struct" href="../location/cluster/struct.Cluster.html" title="struct hydro_lang::location::cluster::Cluster">Cluster</a>&lt;'a, C2&gt;&gt;&gt;::<a class="associatedtype" href="../location/can_send/trait.CanSend.html#associatedtype.Out" title="type hydro_lang::location::can_send::CanSend::Out">Out</a>&lt;Bytes&gt;, <a class="struct" href="../location/cluster/struct.Cluster.html" title="struct hydro_lang::location::cluster::Cluster">Cluster</a>&lt;'a, C2&gt;, <a class="enum" href="../boundedness/enum.Unbounded.html" title="enum hydro_lang::boundedness::Unbounded">Unbounded</a>, &lt;<a class="struct" href="struct.TotalOrder.html" title="struct hydro_lang::stream::TotalOrder">TotalOrder</a> as <a class="trait" href="trait.MinOrder.html" title="trait hydro_lang::stream::MinOrder">MinOrder</a>&lt;&lt;L::<a class="associatedtype" href="../location/trait.Location.html#associatedtype.Root" title="type hydro_lang::location::Location::Root">Root</a> as <a class="trait" href="../location/can_send/trait.CanSend.html" title="trait hydro_lang::location::can_send::CanSend">CanSend</a>&lt;'a, <a class="struct" href="../location/cluster/struct.Cluster.html" title="struct hydro_lang::location::cluster::Cluster">Cluster</a>&lt;'a, C2&gt;&gt;&gt;::<a class="associatedtype" href="../location/can_send/trait.CanSend.html#associatedtype.OutStrongestOrder" title="type hydro_lang::location::can_send::CanSend::OutStrongestOrder">OutStrongestOrder</a>&lt;<a class="struct" href="struct.TotalOrder.html" title="struct hydro_lang::stream::TotalOrder">TotalOrder</a>&gt;&gt;&gt;::<a class="associatedtype" href="trait.MinOrder.html#associatedtype.Min" title="type hydro_lang::stream::MinOrder::Min">Min</a>&gt;<div class="where">where
    L::<a class="associatedtype" href="../location/trait.Location.html#associatedtype.Root" title="type hydro_lang::location::Location::Root">Root</a>: <a class="trait" href="../location/can_send/trait.CanSend.html" title="trait hydro_lang::location::can_send::CanSend">CanSend</a>&lt;'a, <a class="struct" href="../location/cluster/struct.Cluster.html" title="struct hydro_lang::location::cluster::Cluster">Cluster</a>&lt;'a, C2&gt;, In&lt;Bytes&gt; = (<a class="struct" href="../location/cluster/cluster_id/struct.ClusterId.html" title="struct hydro_lang::location::cluster::cluster_id::ClusterId">ClusterId</a>&lt;C2&gt;, T)&gt; + 'a,
    T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,
    <a class="struct" href="struct.TotalOrder.html" title="struct hydro_lang::stream::TotalOrder">TotalOrder</a>: <a class="trait" href="trait.MinOrder.html" title="trait hydro_lang::stream::MinOrder">MinOrder</a>&lt;&lt;L::<a class="associatedtype" href="../location/trait.Location.html#associatedtype.Root" title="type hydro_lang::location::Location::Root">Root</a> as <a class="trait" href="../location/can_send/trait.CanSend.html" title="trait hydro_lang::location::can_send::CanSend">CanSend</a>&lt;'a, <a class="struct" href="../location/cluster/struct.Cluster.html" title="struct hydro_lang::location::cluster::Cluster">Cluster</a>&lt;'a, C2&gt;&gt;&gt;::<a class="associatedtype" href="../location/can_send/trait.CanSend.html#associatedtype.OutStrongestOrder" title="type hydro_lang::location::can_send::CanSend::OutStrongestOrder">OutStrongestOrder</a>&lt;<a class="struct" href="struct.TotalOrder.html" title="struct hydro_lang::stream::TotalOrder">TotalOrder</a>&gt;&gt;,</div></h4></section><section id="method.round_robin_bytes_anonymous" class="method"><a class="src rightside" href="../../src/hydro_lang/stream.rs.html#2188-2207">Source</a><h4 class="code-header">pub fn <a href="#method.round_robin_bytes_anonymous" class="fn">round_robin_bytes_anonymous</a>&lt;C2: 'a, Tag&gt;(
    self,
    other: &amp;<a class="struct" href="../location/cluster/struct.Cluster.html" title="struct hydro_lang::location::cluster::Cluster">Cluster</a>&lt;'a, C2&gt;,
) -&gt; <a class="struct" href="struct.Stream.html" title="struct hydro_lang::stream::Stream">Stream</a>&lt;Bytes, <a class="struct" href="../location/cluster/struct.Cluster.html" title="struct hydro_lang::location::cluster::Cluster">Cluster</a>&lt;'a, C2&gt;, <a class="enum" href="../boundedness/enum.Unbounded.html" title="enum hydro_lang::boundedness::Unbounded">Unbounded</a>, &lt;<a class="struct" href="struct.TotalOrder.html" title="struct hydro_lang::stream::TotalOrder">TotalOrder</a> as <a class="trait" href="trait.MinOrder.html" title="trait hydro_lang::stream::MinOrder">MinOrder</a>&lt;&lt;L::<a class="associatedtype" href="../location/trait.Location.html#associatedtype.Root" title="type hydro_lang::location::Location::Root">Root</a> as <a class="trait" href="../location/can_send/trait.CanSend.html" title="trait hydro_lang::location::can_send::CanSend">CanSend</a>&lt;'a, <a class="struct" href="../location/cluster/struct.Cluster.html" title="struct hydro_lang::location::cluster::Cluster">Cluster</a>&lt;'a, C2&gt;&gt;&gt;::<a class="associatedtype" href="../location/can_send/trait.CanSend.html#associatedtype.OutStrongestOrder" title="type hydro_lang::location::can_send::CanSend::OutStrongestOrder">OutStrongestOrder</a>&lt;<a class="struct" href="struct.TotalOrder.html" title="struct hydro_lang::stream::TotalOrder">TotalOrder</a>&gt;&gt;&gt;::<a class="associatedtype" href="trait.MinOrder.html#associatedtype.Min" title="type hydro_lang::stream::MinOrder::Min">Min</a>&gt;<div class="where">where
    L::<a class="associatedtype" href="../location/trait.Location.html#associatedtype.Root" title="type hydro_lang::location::Location::Root">Root</a>: <a class="trait" href="../location/can_send/trait.CanSend.html" title="trait hydro_lang::location::can_send::CanSend">CanSend</a>&lt;'a, <a class="struct" href="../location/cluster/struct.Cluster.html" title="struct hydro_lang::location::cluster::Cluster">Cluster</a>&lt;'a, C2&gt;, In&lt;Bytes&gt; = (<a class="struct" href="../location/cluster/cluster_id/struct.ClusterId.html" title="struct hydro_lang::location::cluster::cluster_id::ClusterId">ClusterId</a>&lt;C2&gt;, T), Out&lt;Bytes&gt; = (Tag, Bytes)&gt; + 'a,
    T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,
    <a class="struct" href="struct.TotalOrder.html" title="struct hydro_lang::stream::TotalOrder">TotalOrder</a>: <a class="trait" href="trait.MinOrder.html" title="trait hydro_lang::stream::MinOrder">MinOrder</a>&lt;&lt;L::<a class="associatedtype" href="../location/trait.Location.html#associatedtype.Root" title="type hydro_lang::location::Location::Root">Root</a> as <a class="trait" href="../location/can_send/trait.CanSend.html" title="trait hydro_lang::location::can_send::CanSend">CanSend</a>&lt;'a, <a class="struct" href="../location/cluster/struct.Cluster.html" title="struct hydro_lang::location::cluster::Cluster">Cluster</a>&lt;'a, C2&gt;&gt;&gt;::<a class="associatedtype" href="../location/can_send/trait.CanSend.html#associatedtype.OutStrongestOrder" title="type hydro_lang::location::can_send::CanSend::OutStrongestOrder">OutStrongestOrder</a>&lt;<a class="struct" href="struct.TotalOrder.html" title="struct hydro_lang::stream::TotalOrder">TotalOrder</a>&gt;&gt;,</div></h4></section></div></details></div><h2 id="trait-implementations" class="section-header">Trait Implementations<a href="#trait-implementations" class="anchor">§</a></h2><div id="trait-implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Clone-for-Stream%3CT,+L,+B,+Order%3E" class="impl"><a class="src rightside" href="../../src/hydro_lang/stream.rs.html#211-235">Source</a><a href="#impl-Clone-for-Stream%3CT,+L,+B,+Order%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a, T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>, L: <a class="trait" href="../location/trait.Location.html" title="trait hydro_lang::location::Location">Location</a>&lt;'a&gt;, B, Order&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> for <a class="struct" href="struct.Stream.html" title="struct hydro_lang::stream::Stream">Stream</a>&lt;T, L, B, Order&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.clone" class="method trait-impl"><a class="src rightside" href="../../src/hydro_lang/stream.rs.html#212-234">Source</a><a href="#method.clone" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#tymethod.clone" class="fn">clone</a>(&amp;self) -&gt; Self</h4></section></summary><div class='docblock'>Returns a copy of the value. <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#tymethod.clone">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clone_from" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/clone.rs.html#174">Source</a></span><a href="#method.clone_from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#method.clone_from" class="fn">clone_from</a>(&amp;mut self, source: &amp;Self)</h4></section></summary><div class='docblock'>Performs copy-assignment from <code>source</code>. <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#method.clone_from">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-CycleCollection%3C'a,+ForwardRefMarker%3E-for-Stream%3CT,+L,+B,+Order%3E" class="impl"><a class="src rightside" href="../../src/hydro_lang/stream.rs.html#151-171">Source</a><a href="#impl-CycleCollection%3C'a,+ForwardRefMarker%3E-for-Stream%3CT,+L,+B,+Order%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a, T, L: <a class="trait" href="../location/trait.Location.html" title="trait hydro_lang::location::Location">Location</a>&lt;'a&gt; + <a class="trait" href="../location/tick/trait.NoTick.html" title="trait hydro_lang::location::tick::NoTick">NoTick</a>, B, Order&gt; <a class="trait" href="../cycle/trait.CycleCollection.html" title="trait hydro_lang::cycle::CycleCollection">CycleCollection</a>&lt;'a, <a class="enum" href="../cycle/enum.ForwardRefMarker.html" title="enum hydro_lang::cycle::ForwardRefMarker">ForwardRefMarker</a>&gt; for <a class="struct" href="struct.Stream.html" title="struct hydro_lang::stream::Stream">Stream</a>&lt;T, L, B, Order&gt;</h3></section></summary><div class="impl-items"><section id="associatedtype.Location-1" class="associatedtype trait-impl"><a class="src rightside" href="../../src/hydro_lang/stream.rs.html#154">Source</a><a href="#associatedtype.Location-1" class="anchor">§</a><h4 class="code-header">type <a href="../cycle/trait.CycleCollection.html#associatedtype.Location" class="associatedtype">Location</a> = L</h4></section><section id="method.create_source-1" class="method trait-impl"><a class="src rightside" href="../../src/hydro_lang/stream.rs.html#156-170">Source</a><a href="#method.create_source-1" class="anchor">§</a><h4 class="code-header">fn <a href="../cycle/trait.CycleCollection.html#tymethod.create_source" class="fn">create_source</a>(ident: <a class="struct" href="https://docs.rs/proc-macro2/1.0.93/proc_macro2/struct.Ident.html" title="struct proc_macro2::Ident">Ident</a>, location: L) -&gt; Self</h4></section></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-CycleCollection%3C'a,+TickCycleMarker%3E-for-Stream%3CT,+Tick%3CL%3E,+Bounded,+Order%3E" class="impl"><a class="src rightside" href="../../src/hydro_lang/stream.rs.html#109-125">Source</a><a href="#impl-CycleCollection%3C'a,+TickCycleMarker%3E-for-Stream%3CT,+Tick%3CL%3E,+Bounded,+Order%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a, T, L: <a class="trait" href="../location/trait.Location.html" title="trait hydro_lang::location::Location">Location</a>&lt;'a&gt;, Order&gt; <a class="trait" href="../cycle/trait.CycleCollection.html" title="trait hydro_lang::cycle::CycleCollection">CycleCollection</a>&lt;'a, <a class="enum" href="../cycle/enum.TickCycleMarker.html" title="enum hydro_lang::cycle::TickCycleMarker">TickCycleMarker</a>&gt; for <a class="struct" href="struct.Stream.html" title="struct hydro_lang::stream::Stream">Stream</a>&lt;T, <a class="struct" href="../location/tick/struct.Tick.html" title="struct hydro_lang::location::tick::Tick">Tick</a>&lt;L&gt;, <a class="enum" href="../boundedness/enum.Bounded.html" title="enum hydro_lang::boundedness::Bounded">Bounded</a>, Order&gt;</h3></section></summary><div class="impl-items"><section id="associatedtype.Location" class="associatedtype trait-impl"><a class="src rightside" href="../../src/hydro_lang/stream.rs.html#112">Source</a><a href="#associatedtype.Location" class="anchor">§</a><h4 class="code-header">type <a href="../cycle/trait.CycleCollection.html#associatedtype.Location" class="associatedtype">Location</a> = <a class="struct" href="../location/tick/struct.Tick.html" title="struct hydro_lang::location::tick::Tick">Tick</a>&lt;L&gt;</h4></section><section id="method.create_source" class="method trait-impl"><a class="src rightside" href="../../src/hydro_lang/stream.rs.html#114-124">Source</a><a href="#method.create_source" class="anchor">§</a><h4 class="code-header">fn <a href="../cycle/trait.CycleCollection.html#tymethod.create_source" class="fn">create_source</a>(ident: <a class="struct" href="https://docs.rs/proc-macro2/1.0.93/proc_macro2/struct.Ident.html" title="struct proc_macro2::Ident">Ident</a>, location: <a class="struct" href="../location/tick/struct.Tick.html" title="struct hydro_lang::location::tick::Tick">Tick</a>&lt;L&gt;) -&gt; Self</h4></section></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-CycleComplete%3C'a,+ForwardRefMarker%3E-for-Stream%3CT,+L,+B,+Order%3E" class="impl"><a class="src rightside" href="../../src/hydro_lang/stream.rs.html#173-199">Source</a><a href="#impl-CycleComplete%3C'a,+ForwardRefMarker%3E-for-Stream%3CT,+L,+B,+Order%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a, T, L: <a class="trait" href="../location/trait.Location.html" title="trait hydro_lang::location::Location">Location</a>&lt;'a&gt; + <a class="trait" href="../location/tick/trait.NoTick.html" title="trait hydro_lang::location::tick::NoTick">NoTick</a>, B, Order&gt; <a class="trait" href="../cycle/trait.CycleComplete.html" title="trait hydro_lang::cycle::CycleComplete">CycleComplete</a>&lt;'a, <a class="enum" href="../cycle/enum.ForwardRefMarker.html" title="enum hydro_lang::cycle::ForwardRefMarker">ForwardRefMarker</a>&gt; for <a class="struct" href="struct.Stream.html" title="struct hydro_lang::stream::Stream">Stream</a>&lt;T, L, B, Order&gt;</h3></section></summary><div class="impl-items"><section id="method.complete-1" class="method trait-impl"><a class="src rightside" href="../../src/hydro_lang/stream.rs.html#176-198">Source</a><a href="#method.complete-1" class="anchor">§</a><h4 class="code-header">fn <a href="../cycle/trait.CycleComplete.html#tymethod.complete" class="fn">complete</a>(self, ident: <a class="struct" href="https://docs.rs/proc-macro2/1.0.93/proc_macro2/struct.Ident.html" title="struct proc_macro2::Ident">Ident</a>, expected_location: <a class="enum" href="../location/enum.LocationId.html" title="enum hydro_lang::location::LocationId">LocationId</a>)</h4></section></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-CycleComplete%3C'a,+TickCycleMarker%3E-for-Stream%3CT,+Tick%3CL%3E,+Bounded,+Order%3E" class="impl"><a class="src rightside" href="../../src/hydro_lang/stream.rs.html#127-149">Source</a><a href="#impl-CycleComplete%3C'a,+TickCycleMarker%3E-for-Stream%3CT,+Tick%3CL%3E,+Bounded,+Order%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a, T, L: <a class="trait" href="../location/trait.Location.html" title="trait hydro_lang::location::Location">Location</a>&lt;'a&gt;, Order&gt; <a class="trait" href="../cycle/trait.CycleComplete.html" title="trait hydro_lang::cycle::CycleComplete">CycleComplete</a>&lt;'a, <a class="enum" href="../cycle/enum.TickCycleMarker.html" title="enum hydro_lang::cycle::TickCycleMarker">TickCycleMarker</a>&gt; for <a class="struct" href="struct.Stream.html" title="struct hydro_lang::stream::Stream">Stream</a>&lt;T, <a class="struct" href="../location/tick/struct.Tick.html" title="struct hydro_lang::location::tick::Tick">Tick</a>&lt;L&gt;, <a class="enum" href="../boundedness/enum.Bounded.html" title="enum hydro_lang::boundedness::Bounded">Bounded</a>, Order&gt;</h3></section></summary><div class="impl-items"><section id="method.complete" class="method trait-impl"><a class="src rightside" href="../../src/hydro_lang/stream.rs.html#130-148">Source</a><a href="#method.complete" class="anchor">§</a><h4 class="code-header">fn <a href="../cycle/trait.CycleComplete.html#tymethod.complete" class="fn">complete</a>(self, ident: <a class="struct" href="https://docs.rs/proc-macro2/1.0.93/proc_macro2/struct.Ident.html" title="struct proc_macro2::Ident">Ident</a>, expected_location: <a class="enum" href="../location/enum.LocationId.html" title="enum hydro_lang::location::LocationId">LocationId</a>)</h4></section></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-DeferTick-for-Stream%3CT,+Tick%3CL%3E,+Bounded,+Order%3E" class="impl"><a class="src rightside" href="../../src/hydro_lang/stream.rs.html#103-107">Source</a><a href="#impl-DeferTick-for-Stream%3CT,+Tick%3CL%3E,+Bounded,+Order%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a, T, L: <a class="trait" href="../location/trait.Location.html" title="trait hydro_lang::location::Location">Location</a>&lt;'a&gt;, Order&gt; <a class="trait" href="../cycle/trait.DeferTick.html" title="trait hydro_lang::cycle::DeferTick">DeferTick</a> for <a class="struct" href="struct.Stream.html" title="struct hydro_lang::stream::Stream">Stream</a>&lt;T, <a class="struct" href="../location/tick/struct.Tick.html" title="struct hydro_lang::location::tick::Tick">Tick</a>&lt;L&gt;, <a class="enum" href="../boundedness/enum.Bounded.html" title="enum hydro_lang::boundedness::Bounded">Bounded</a>, Order&gt;</h3></section></summary><div class="impl-items"><section id="method.defer_tick-1" class="method trait-impl"><a class="src rightside" href="../../src/hydro_lang/stream.rs.html#104-106">Source</a><a href="#method.defer_tick-1" class="anchor">§</a><h4 class="code-header">fn <a href="../cycle/trait.DeferTick.html#tymethod.defer_tick" class="fn">defer_tick</a>(self) -&gt; Self</h4></section></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3CStream%3CT,+L,+B%3E%3E-for-Stream%3CT,+L,+B,+NoOrder%3E" class="impl"><a class="src rightside" href="../../src/hydro_lang/stream.rs.html#87-95">Source</a><a href="#impl-From%3CStream%3CT,+L,+B%3E%3E-for-Stream%3CT,+L,+B,+NoOrder%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a, T, L: <a class="trait" href="../location/trait.Location.html" title="trait hydro_lang::location::Location">Location</a>&lt;'a&gt;, B&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="struct" href="struct.Stream.html" title="struct hydro_lang::stream::Stream">Stream</a>&lt;T, L, B&gt;&gt; for <a class="struct" href="struct.Stream.html" title="struct hydro_lang::stream::Stream">Stream</a>&lt;T, L, B, <a class="struct" href="struct.NoOrder.html" title="struct hydro_lang::stream::NoOrder">NoOrder</a>&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-1" class="method trait-impl"><a class="src rightside" href="../../src/hydro_lang/stream.rs.html#88-94">Source</a><a href="#method.from-1" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(stream: <a class="struct" href="struct.Stream.html" title="struct hydro_lang::stream::Stream">Stream</a>&lt;T, L, B, <a class="struct" href="struct.TotalOrder.html" title="struct hydro_lang::stream::TotalOrder">TotalOrder</a>&gt;) -&gt; <a class="struct" href="struct.Stream.html" title="struct hydro_lang::stream::Stream">Stream</a>&lt;T, L, B, <a class="struct" href="struct.NoOrder.html" title="struct hydro_lang::stream::NoOrder">NoOrder</a>&gt;</h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3CStream%3CT,+L,+Bounded,+O%3E%3E-for-Stream%3CT,+L,+Unbounded,+O%3E" class="impl"><a class="src rightside" href="../../src/hydro_lang/stream.rs.html#77-85">Source</a><a href="#impl-From%3CStream%3CT,+L,+Bounded,+O%3E%3E-for-Stream%3CT,+L,+Unbounded,+O%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a, T, L: <a class="trait" href="../location/trait.Location.html" title="trait hydro_lang::location::Location">Location</a>&lt;'a&gt;, O&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="struct" href="struct.Stream.html" title="struct hydro_lang::stream::Stream">Stream</a>&lt;T, L, <a class="enum" href="../boundedness/enum.Bounded.html" title="enum hydro_lang::boundedness::Bounded">Bounded</a>, O&gt;&gt; for <a class="struct" href="struct.Stream.html" title="struct hydro_lang::stream::Stream">Stream</a>&lt;T, L, <a class="enum" href="../boundedness/enum.Unbounded.html" title="enum hydro_lang::boundedness::Unbounded">Unbounded</a>, O&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from" class="method trait-impl"><a class="src rightside" href="../../src/hydro_lang/stream.rs.html#78-84">Source</a><a href="#method.from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(stream: <a class="struct" href="struct.Stream.html" title="struct hydro_lang::stream::Stream">Stream</a>&lt;T, L, <a class="enum" href="../boundedness/enum.Bounded.html" title="enum hydro_lang::boundedness::Bounded">Bounded</a>, O&gt;) -&gt; <a class="struct" href="struct.Stream.html" title="struct hydro_lang::stream::Stream">Stream</a>&lt;T, L, <a class="enum" href="../boundedness/enum.Unbounded.html" title="enum hydro_lang::boundedness::Unbounded">Unbounded</a>, O&gt;</h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details></div><h2 id="synthetic-implementations" class="section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor">§</a></h2><div id="synthetic-implementations-list"><section id="impl-Freeze-for-Stream%3CT,+L,+B,+Order%3E" class="impl"><a href="#impl-Freeze-for-Stream%3CT,+L,+B,+Order%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T, L, B, Order = <a class="struct" href="struct.TotalOrder.html" title="struct hydro_lang::stream::TotalOrder">TotalOrder</a>&gt; !<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Freeze.html" title="trait core::marker::Freeze">Freeze</a> for <a class="struct" href="struct.Stream.html" title="struct hydro_lang::stream::Stream">Stream</a>&lt;T, L, B, Order&gt;</h3></section><section id="impl-RefUnwindSafe-for-Stream%3CT,+L,+B,+Order%3E" class="impl"><a href="#impl-RefUnwindSafe-for-Stream%3CT,+L,+B,+Order%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T, L, B, Order = <a class="struct" href="struct.TotalOrder.html" title="struct hydro_lang::stream::TotalOrder">TotalOrder</a>&gt; !<a class="trait" href="https://doc.rust-lang.org/nightly/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="struct.Stream.html" title="struct hydro_lang::stream::Stream">Stream</a>&lt;T, L, B, Order&gt;</h3></section><section id="impl-Send-for-Stream%3CT,+L,+B,+Order%3E" class="impl"><a href="#impl-Send-for-Stream%3CT,+L,+B,+Order%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T, L, B, Order = <a class="struct" href="struct.TotalOrder.html" title="struct hydro_lang::stream::TotalOrder">TotalOrder</a>&gt; !<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="struct.Stream.html" title="struct hydro_lang::stream::Stream">Stream</a>&lt;T, L, B, Order&gt;</h3></section><section id="impl-Sync-for-Stream%3CT,+L,+B,+Order%3E" class="impl"><a href="#impl-Sync-for-Stream%3CT,+L,+B,+Order%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T, L, B, Order = <a class="struct" href="struct.TotalOrder.html" title="struct hydro_lang::stream::TotalOrder">TotalOrder</a>&gt; !<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="struct.Stream.html" title="struct hydro_lang::stream::Stream">Stream</a>&lt;T, L, B, Order&gt;</h3></section><section id="impl-Unpin-for-Stream%3CT,+L,+B,+Order%3E" class="impl"><a href="#impl-Unpin-for-Stream%3CT,+L,+B,+Order%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T, L, B, Order&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="struct" href="struct.Stream.html" title="struct hydro_lang::stream::Stream">Stream</a>&lt;T, L, B, Order&gt;<div class="where">where
    L: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a>,
    T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a>,
    B: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a>,
    Order: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a>,</div></h3></section><section id="impl-UnwindSafe-for-Stream%3CT,+L,+B,+Order%3E" class="impl"><a href="#impl-UnwindSafe-for-Stream%3CT,+L,+B,+Order%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T, L, B, Order = <a class="struct" href="struct.TotalOrder.html" title="struct hydro_lang::stream::TotalOrder">TotalOrder</a>&gt; !<a class="trait" href="https://doc.rust-lang.org/nightly/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a> for <a class="struct" href="struct.Stream.html" title="struct hydro_lang::stream::Stream">Stream</a>&lt;T, L, B, Order&gt;</h3></section></div><h2 id="blanket-implementations" class="section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor">§</a></h2><div id="blanket-implementations-list"><details class="toggle implementors-toggle"><summary><section id="impl-Any-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/any.rs.html#138">Source</a><a href="#impl-Any-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T<div class="where">where
    T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/any.rs.html#139">Source</a><a href="#method.type_id" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html#tymethod.type_id" class="fn">type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></h4></section></summary><div class='docblock'>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html#tymethod.type_id">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#209">Source</a><a href="#impl-Borrow%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#211">Source</a><a href="#method.borrow" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html#tymethod.borrow" class="fn">borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;T</a></h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#217">Source</a><a href="#impl-BorrowMut%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#218">Source</a><a href="#method.borrow_mut" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fn">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut T</a></h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-CloneToUninit-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/clone.rs.html#326">Source</a><a href="#impl-CloneToUninit-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.CloneToUninit.html" title="trait core::clone::CloneToUninit">CloneToUninit</a> for T<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.clone_to_uninit" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/clone.rs.html#328">Source</a><a href="#method.clone_to_uninit" class="anchor">§</a><h4 class="code-header">unsafe fn <a href="https://doc.rust-lang.org/nightly/core/clone/trait.CloneToUninit.html#tymethod.clone_to_uninit" class="fn">clone_to_uninit</a>(&amp;self, dst: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.pointer.html">*mut </a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>)</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>clone_to_uninit</code>)</span></div></span><div class='docblock'>Performs copy-assignment from <code>self</code> to <code>dst</code>. <a href="https://doc.rust-lang.org/nightly/core/clone/trait.CloneToUninit.html#tymethod.clone_to_uninit">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-DynClone-for-T" class="impl"><a class="src rightside" href="https://docs.rs/dyn-clone/1.0.17/src/dyn_clone/lib.rs.html#193-195">Source</a><a href="#impl-DynClone-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://docs.rs/dyn-clone/1.0.17/dyn_clone/trait.DynClone.html" title="trait dyn_clone::DynClone">DynClone</a> for T<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</div></h3></section></summary><div class="impl-items"><section id="method.__clone_box" class="method trait-impl"><a class="src rightside" href="https://docs.rs/dyn-clone/1.0.17/src/dyn_clone/lib.rs.html#197">Source</a><a href="#method.__clone_box" class="anchor">§</a><h4 class="code-header">fn <a href="https://docs.rs/dyn-clone/1.0.17/dyn_clone/trait.DynClone.html#tymethod.__clone_box" class="fn">__clone_box</a>(&amp;self, _: Private) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.pointer.html">*mut </a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a></h4></section></div></details><details class="toggle implementors-toggle"><summary><section id="impl-From%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#767">Source</a><a href="#impl-From%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-2" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#770">Source</a><a href="#method.from-2" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Instrument-for-T" class="impl"><a href="#impl-Instrument-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; Instrument for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.instrument" class="method trait-impl"><a href="#method.instrument" class="anchor">§</a><h4 class="code-header">fn <a class="fn">instrument</a>(self, span: Span) -&gt; Instrumented&lt;Self&gt;</h4></section></summary><div class='docblock'>Instruments this type with the provided [<code>Span</code>], returning an
<code>Instrumented</code> wrapper. <a>Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.in_current_span" class="method trait-impl"><a href="#method.in_current_span" class="anchor">§</a><h4 class="code-header">fn <a class="fn">in_current_span</a>(self) -&gt; Instrumented&lt;Self&gt;</h4></section></summary><div class='docblock'>Instruments this type with the <a href="super::Span::current()">current</a> <a href="crate::Span"><code>Span</code></a>, returning an
<code>Instrumented</code> wrapper. <a>Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#750-752">Source</a><a href="#impl-Into%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#760">Source</a><a href="#method.into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html#tymethod.into" class="fn">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code><a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-IntoEither-for-T" class="impl"><a class="src rightside" href="https://docs.rs/either/1/src/either/into_either.rs.html#64">Source</a><a href="#impl-IntoEither-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://docs.rs/either/1/either/into_either/trait.IntoEither.html" title="trait either::into_either::IntoEither">IntoEither</a> for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into_either" class="method trait-impl"><a class="src rightside" href="https://docs.rs/either/1/src/either/into_either.rs.html#29">Source</a><a href="#method.into_either" class="anchor">§</a><h4 class="code-header">fn <a href="https://docs.rs/either/1/either/into_either/trait.IntoEither.html#method.into_either" class="fn">into_either</a>(self, into_left: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>) -&gt; <a class="enum" href="https://docs.rs/either/1/either/enum.Either.html" title="enum either::Either">Either</a>&lt;Self, Self&gt;</h4></section></summary><div class='docblock'>Converts <code>self</code> into a <a href="https://docs.rs/either/1/either/enum.Either.html#variant.Left" title="variant either::Either::Left"><code>Left</code></a> variant of <a href="https://docs.rs/either/1/either/enum.Either.html" title="enum either::Either"><code>Either&lt;Self, Self&gt;</code></a>
if <code>into_left</code> is <code>true</code>.
Converts <code>self</code> into a <a href="https://docs.rs/either/1/either/enum.Either.html#variant.Right" title="variant either::Either::Right"><code>Right</code></a> variant of <a href="https://docs.rs/either/1/either/enum.Either.html" title="enum either::Either"><code>Either&lt;Self, Self&gt;</code></a>
otherwise. <a href="https://docs.rs/either/1/either/into_either/trait.IntoEither.html#method.into_either">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.into_either_with" class="method trait-impl"><a class="src rightside" href="https://docs.rs/either/1/src/either/into_either.rs.html#55-57">Source</a><a href="#method.into_either_with" class="anchor">§</a><h4 class="code-header">fn <a href="https://docs.rs/either/1/either/into_either/trait.IntoEither.html#method.into_either_with" class="fn">into_either_with</a>&lt;F&gt;(self, into_left: F) -&gt; <a class="enum" href="https://docs.rs/either/1/either/enum.Either.html" title="enum either::Either">Either</a>&lt;Self, Self&gt;<div class="where">where
    F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(&amp;Self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>,</div></h4></section></summary><div class='docblock'>Converts <code>self</code> into a <a href="https://docs.rs/either/1/either/enum.Either.html#variant.Left" title="variant either::Either::Left"><code>Left</code></a> variant of <a href="https://docs.rs/either/1/either/enum.Either.html" title="enum either::Either"><code>Either&lt;Self, Self&gt;</code></a>
if <code>into_left(&amp;self)</code> returns <code>true</code>.
Converts <code>self</code> into a <a href="https://docs.rs/either/1/either/enum.Either.html#variant.Right" title="variant either::Either::Right"><code>Right</code></a> variant of <a href="https://docs.rs/either/1/either/enum.Either.html" title="enum either::Either"><code>Either&lt;Self, Self&gt;</code></a>
otherwise. <a href="https://docs.rs/either/1/either/into_either/trait.IntoEither.html#method.into_either_with">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-MinOrder%3CT%3E-for-T" class="impl"><a class="src rightside" href="../../src/hydro_lang/stream.rs.html#47-49">Source</a><a href="#impl-MinOrder%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="trait.MinOrder.html" title="trait hydro_lang::stream::MinOrder">MinOrder</a>&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Min" class="associatedtype trait-impl"><a class="src rightside" href="../../src/hydro_lang/stream.rs.html#48">Source</a><a href="#associatedtype.Min" class="anchor">§</a><h4 class="code-header">type <a href="trait.MinOrder.html#associatedtype.Min" class="associatedtype">Min</a> = T</h4></section></summary><div class='docblock'>The weaker of the two orderings.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Same-for-T" class="impl"><a class="src rightside" href="https://docs.rs/typenum/1.17.0/src/typenum/type_operators.rs.html#34">Source</a><a href="#impl-Same-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://docs.rs/typenum/1.17.0/typenum/type_operators/trait.Same.html" title="trait typenum::type_operators::Same">Same</a> for T</h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output" class="associatedtype trait-impl"><a class="src rightside" href="https://docs.rs/typenum/1.17.0/src/typenum/type_operators.rs.html#35">Source</a><a href="#associatedtype.Output" class="anchor">§</a><h4 class="code-header">type <a href="https://docs.rs/typenum/1.17.0/typenum/type_operators/trait.Same.html#associatedtype.Output" class="associatedtype">Output</a> = T</h4></section></summary><div class='docblock'>Should always be <code>Self</code></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-ToOwned-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/alloc/borrow.rs.html#82-84">Source</a><a href="#impl-ToOwned-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html" title="trait alloc::borrow::ToOwned">ToOwned</a> for T<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Owned" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/alloc/borrow.rs.html#86">Source</a><a href="#associatedtype.Owned" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#associatedtype.Owned" class="associatedtype">Owned</a> = T</h4></section></summary><div class='docblock'>The resulting type after obtaining ownership.</div></details><details class="toggle method-toggle" open><summary><section id="method.to_owned" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/alloc/borrow.rs.html#87">Source</a><a href="#method.to_owned" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#tymethod.to_owned" class="fn">to_owned</a>(&amp;self) -&gt; T</h4></section></summary><div class='docblock'>Creates owned data from borrowed data, usually by cloning. <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#tymethod.to_owned">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clone_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/alloc/borrow.rs.html#91">Source</a><a href="#method.clone_into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#method.clone_into" class="fn">clone_into</a>(&amp;self, target: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut T</a>)</h4></section></summary><div class='docblock'>Uses borrowed data to replace owned data, usually by cloning. <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#method.clone_into">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#806-808">Source</a><a href="#impl-TryFrom%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error-1" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#810">Source</a><a href="#associatedtype.Error-1" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="enum" href="https://doc.rust-lang.org/nightly/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#813">Source</a><a href="#method.try_from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#tymethod.try_from" class="fn">try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#791-793">Source</a><a href="#impl-TryInto%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#795">Source</a><a href="#associatedtype.Error" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html#associatedtype.Error" class="associatedtype">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#798">Source</a><a href="#method.try_into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html#tymethod.try_into" class="fn">try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-VZip%3CV%3E-for-T" class="impl"><a href="#impl-VZip%3CV%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;V, T&gt; VZip&lt;V&gt; for T<div class="where">where
    V: MultiLane&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><section id="method.vzip" class="method trait-impl"><a href="#method.vzip" class="anchor">§</a><h4 class="code-header">fn <a class="fn">vzip</a>(self) -&gt; V</h4></section></div></details><details class="toggle implementors-toggle"><summary><section id="impl-WithSubscriber-for-T" class="impl"><a href="#impl-WithSubscriber-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; WithSubscriber for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.with_subscriber" class="method trait-impl"><a href="#method.with_subscriber" class="anchor">§</a><h4 class="code-header">fn <a class="fn">with_subscriber</a>&lt;S&gt;(self, subscriber: S) -&gt; WithDispatch&lt;Self&gt;<div class="where">where
    S: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;Dispatch&gt;,</div></h4></section></summary><div class='docblock'>Attaches the provided <a href="super::Subscriber"><code>Subscriber</code></a> to this type, returning a
[<code>WithDispatch</code>] wrapper. <a>Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.with_current_subscriber" class="method trait-impl"><a href="#method.with_current_subscriber" class="anchor">§</a><h4 class="code-header">fn <a class="fn">with_current_subscriber</a>(self) -&gt; WithDispatch&lt;Self&gt;</h4></section></summary><div class='docblock'>Attaches the current <a href="crate::dispatcher#setting-the-default-subscriber">default</a> <a href="super::Subscriber"><code>Subscriber</code></a> to this type, returning a
[<code>WithDispatch</code>] wrapper. <a>Read more</a></div></details></div></details><section id="impl-ErasedDestructor-for-T" class="impl"><a href="#impl-ErasedDestructor-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; ErasedDestructor for T<div class="where">where
    T: 'static,</div></h3></section><section id="impl-MaybeSendSync-for-T" class="impl"><a href="#impl-MaybeSendSync-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; MaybeSendSync for T</h3></section></div></section></div></main></body></html>